## Kafka

> Устройство Kafka в общих чертах?

- Брокеры: Это серверы, на которых работает Kafka. Каждый брокер отвечает за хранение и обработку сообщений.
- Топики: Сообщения в Kafka организованы по темам, называемым топиками. Каждый топик может иметь несколько 
	партиций, что позволяет распределять нагрузку между брокерами и обеспечивать параллельную обработку.
- Партиции: Это подмножества данных внутри топика. Каждая партиция — это упорядоченная последовательность 
	сообщений, которая может быть обработана независимо от других партиций.
- Производители (Producers): Это клиенты, которые отправляют (публикуют) сообщения в топики. Производители 
	могут выбирать, в какую партицию отправить сообщение, основываясь на ключе или других критериях.
- Потребители (Consumers): Это клиенты, которые читают (подписываются на) сообщения из топиков. Потребители 
	могут работать по одиночке или объединяться в группы, чтобы совместно обрабатывать сообщения.
- Группы потребителей: Позволяют нескольким потребителям работать вместе, чтобы обрабатывать сообщения из 
	одного топика.

> Может ли consumer заставить читать из конкретной партиции?

Да. Вместо subscribe, юзать метод assign с указанием конкретной партиции.

> Партиции в Kafka?

В Kafka партиции используются для разделения сообщений по темам. Каждая тема может иметь несколько партиций, и сообщения, относящиеся к одной теме, распределяются по этим партициям. 

---

## JUnit

> Как запустить тестовые методы в определенном порядке?

@TestMethodOrder

---

## Spring Framework

> Что такое фреймворк?

Фреймворк - это инструмент, предоставляющий набор расширяемых шабонов разработки ПО. Управляет жизненным циклом чего-то.

> Что такое Inversion of controle? 

Общее понятие, когда мы отдаем управлением чем-то фрейморвку. Реализацией является Dependencty Injection. 

> Что такое Dependency injection?

Внедрение зависимостей - когда фреймворк обладает управлением над внедрением бинов в зависимости

> Жизненный цикл бина?

1. Создание BeanDefinition
2. Возможность создать свои BeanDefinition(через ImportBeanDefinitionRegistrar)
3. Пост обработка BeanDefinition
4. Создание бинов и внедрение через конструктор
5. Внедрение через сеттеры и поля (в т.ч. через @Value)
6. Вызовы методов Aware-интерфейсов ????? (вроде как для инфраструктурных бинов) - не юзать (bad practice)
7. Пост-обработка бина (1-й этап) (через BeanPostProcessor) (можно встретить прокси при работе с бинами)
8. Вызов методов инициализации (@PostConstruct, InitializingBean, Custom init method (@Bean))
9. Пост-обработка бина (2-й этап) (через BeanPostProcessor)
10. Бин готов к работе
11. Завершение работы
12. Вызов методов деинициализации (@PreDestroy, DisposableBean, Custom destroy method (@Bean))

> Что такое прокси-объект?

прокси-объект - это объект, который служит посредником для доступа к другому объекту, меняя свойства или поведение этого объекта с помощью аспектов.

> Где применяется AOP?

Логирование, транзакции, авторизация, метрики, кэширование, обработка исключений

> Что такое Aspect?

Это класс, содержащий эдвайсы, определяющие дополнительную функциональность прокси-объектов

> Для чего нужен Spring Boot?

Для использования стартеров, содержащих готовый кусок автосконфигурированного контекста + условные бины (ConditionOn...), а также для подключения готового пакета зависимостей, подобранных по версиям

> Что такое REST?

это архитектурный стиль, используемый для обмена данными в вебе в формате клиент-сервер.

---

## JavaCore

> Свойства транзакций?  

`ACID` 
1. Атомарность - все или ничего
2. Консистентность - результат транзакции становится доступен всем потребителям по окончании транзакции
под консистентностью понимает переход из одного состояния в другое (счет с деньгами до и после перевода)
3. Изоляция - транзакции друг на друга никак не влияют
4. Дурабилити - результат выполнения транзакции будет сохранен и откату уже не подлежит

> Уровни вложенности транзакций (propagation)?  

1. Propagation.**REQUIRED** (дефолтное) - если нет транзакции, то она будет создана. Если произойдет Rollback, то откатятся обе 
2. Propagation.**REQUIRED_NEW** - создание новой транзакции в вызываемОМ методе. Транзакция в вызывающЕМ будет приостановлена и возобновлена по завершению вложенной. (пример: попытка списания денег со счета должна быть зафиксирована даже тогда, когда списание в итоге не произошло)
3. Propagation.**SUPPORT** - если есть транзакция над вызывающим методом - то будет исполнена, если нет - то метод исполнится без транзакции (БЕСПОЛЕЗНАЯ)
4. Propagation.**MANDATORY** - если нет транзакции, то будет брошено ИСКЛЮЧЕНИЕ (исп. на методах Репозитория)
5. Propagation.**NOT_SUPPORTED** - в момент выполения метода приостанавливаются любые внешние транзакции, чтобы тело метода было выполнено **нетранзакционно**
6. Propagation.**NEVER** - если испольуется транзакция, то бросается ИСКЛЮЧЕНИЕ
7. Propagation.**NESTED** - запускается во внутренней транзакции, если текущая существует (НА УРОВНЕ `БД`)

> Уровни изолиции транзакций (isolation)?

1. **Read Uncommitted**: транзакции могут видеть нефиксированные изменения, сделанные другими транзакциями.
2. **Read Committed**: транзакция может читать только зафиксированные изменения.
3. **Repeatable Read**: если транзакция прочитала строку, никакая другая транзакция не может изменить её до завершения первой транзакции.
4. **Serializable**: самый строгий уровень изолированности. Транзакции выполняются так, как если бы они выполнялись последовательно, не допуская пересечения.


> Какой стратегии наследования Entity нет в JPA? 

Общая таблица для всей иерархии

> Разница между @Before/BeforeEach и @BeforeClass/BeforeClass?

@B вызывается перед каждым тестом, @BC вызывается один раз

> Как получить имя текущего исполняемого теста в JUnit 4? (Google)

TestName-Rule

> В чем отличие между интерфейсами Comparable и Comparator?

Comparable используется для того, что бы задать естественный порядок объекту, Comparator позволяет создавать объекты, которые будут управлять процессом сравнения, например для сортировки.

> Какой метод позволяет получить Connection из Session? 

session.connection()

> Какая минимальная версия Java поддерживается в Spring Boot 2 и Spring 5? (Google)

8

> Как условно игнорировать тесты в JUnit 4?

@Ignore . В JUnit5 - @Disable


> Выберите подходящее определение сервлета

Сервлет является интерфейсом Java, реализация которого позволяет обрабатывать HTTP-запросы
(да, но в своей реализации я наследовался от абстрактного класса AbstractAnnotationConfigDispatcherServletInitializer)

> Как создать свой unchecked Exception?

Наследоваться от RuntimeException

> Какой интерфейс в JPA описывает методы для основных операций над Entity? 

EntityManager

> Какие различия между Mock и Spy

S если не был подвержен stubbing-у, то вызовет настоящую реализацию

> Какое значение имеет порядок объявления столбцов в составном индексе?

Первый столбец должен  максимально ограничивать последующую выборку.

> Можем ли мы применить @Autowired с не сеттерами и не конструкторами?

Да, ещё можем с полями класса

> Сколько может быть кластеризованных индексов в одной таблице?

1

> Назовите все методы класса Object :

1. notify();
2. notifyAll();
3. clone()
4. toString
5. equals
6. wait(long msecs);
7. hashCode()
8. getClass()
9. finalize - Depricated - вызывается перед удалением неиспользуемого объекта;

> Что такое Entity?

POJO-класс, связанный с БД с помощью аннотации (@Entity) или через XML

> Чем отличается JDBC Statement от PreparedStatement? 

Statement используется для выполнения простых SQL-запросов к БД, 
PreparedStatement используется для выполнения прекомпилированных запросов с параметрами.

> Любая ли операция SQL может содержаться в транзакции?

Операции, которые могут быть частью транзакции, это обычно операции INSERT, UPDATE и DELETE, то есть операции с манипуляцией данными.  
Операции, которые обычно не могут быть частью транзакции, это операции DDL, такие как CREATE, ALTER, DROP, так как если мы выполним, допустим, операцию по созданию таблицы, то она в рамках транзакции не может быть отменена, даже если мы захотим откатить транзакцию.   
Также частью транзакции не могут быть команды COMMIT и ROLLBACK, которые, помимо Java также есть в SQL, так как они сами по себе управляют данной транзакцией.

> Что такое пессимистические и оптимистические блокировки?

  * оптимистичная - исп. версионность изменений в таблице и проверка версии записи перед обновлением. При попытке изменения записи другой версии - WrongVersionException или подобное (исп. когда много чтения и мало изменения)
  * пессимистичная - блокировка записи в БД, когда не позволит зайти другой транзакции (медленнее работает на чтении, исп. на частых модификациях)

 > На какие столбцы нужно навесить индексы в базе?

* На столбцы, которые часто используются в выборке по условию WHERE
* На столбцы, которые часто объединяются в JOINах, это значительно ускорит процесс объединения
* На столбцы, которые часто используются в выборке по условиям GROUP BY и ORDER BY

> Обязательно ли в Java за блоком try идет catch?

За блоком try не обязательно должен идти блок catch, но при таком сценарии за try должен идти блок finally.  
Таким образом возможны три варианта: try с 1+ блоком catch, try с finally и try, catch, finally.

> В блоке try ошибка, в блоке finally при закрытии ресурсов также ошибка, какую ошибку получим в результате?

Если в блоке try происходит исключение, и затем в блоке finally происходит другое исключение, то исключение из блока finally будет тем исключением, которое будет фактически выброшено.

> Цикл существования Entity?  

* Transient - новый объект, его ни в БД, ни в Кэше первого уровня(контексте)
* Persistence - объект есть в БД и контексте
* Detached - объект есть в БД, но отсутствует в контексте
* Removed - объекта нет ни в БД, ни в контексте

> Как в теории(может и на практике) остановить Spring приложение?

Если приложение поднято в Docker, то можно ввести команду docker stop, а если через Kubernetes, то ввести команду kubectl delete pod <pod_name>. Если приложение использует Spring boot и включен Actuator, то можно отправить POST запрос на эндпоинт /shotdown

> Что делает команда git cherry-pick?

Для копирования выбранного коммита из одной ветки в конец другой в виде нового коммита. При этом, вторая ветка остается прежней

> Что такое распределенная транзакция?

Это транзакции, которые охватывают несколько сетевых узлов или баз данных. Для этих целей может быть общей диспетчер транзакций (ждет сообщения от обеих БД о готовности к коммитам)

> Принципы ООП?

**Инкапсуляция** - предназначена для изоляции контрактных обязательств (в интерфейсе) от их реализации (в объекте, который совершает имплементацию). На практике это означает, что класс должен состоять из двух частей: интерфейса (не тип класса, а абстрактное понятие) и реализации + мотидикаторы доступа  
**Наследование** – это свойство системы, позволяющее описать новый класс на основе уже существующего, с частично или полностью заимствующейся функциональностью.  
**Полиморфизм** – возможность идентично использовать объекты с одинаковым интерфейсом без информации о конкретном типе этого объекта + возможность переопределять методы + возможность перегружать методы (разное количество и тип входные аргументов).  
**Абстракция** - принцип проектирования объекта по характеристикам, справедливым для каждого из экземпляров класса.   

> Что такое сигнатура метода?
Имя метода + аргументы. Используется при перегрузке методов

> Что такое перегрузка методов?

Свойство полиморфизма, позволяющее создать методы с одним названием, но разным количеством и типом принимаемых аргументов. Кроме того, может отличаться возвращаемый тип данных

> В чем разница между model.put() и model.addAttribute()?

addAttribute это обертка над put, где делается дополнительная проверка на null.

> В чем разница между IOC (Inversion of Control) и Application Context?

AC реализация IOC

> В чем разница между Сквозной Функциональностью (Cross Cutting Concerns) и АОП?

Это концептуально разные вещи. Однако реализацией Сквозной функциональности являются эдвайсы, предоставляемые АОП

> Что такое нормализация в реляционных базах данных?

Устранение избыточности данных.

> Какой механизм используется в HashMap для разрешения коллизий?

Метод цепочек (бакеты)

> Что является монитором при вызове синхронизированного СТАТИЧЕСКОГО метода?

объект типа Class, соответствующий классу, в котором определен этот метод.

> Что такое Hibernate Criteria?  

Позволяет выполнять запросы в БД без написания SQL кода.

> Для чего служат callback методы в JPA? 

Эти методы вызываются при наступлении определенных событий в жизненном цикле entity

> Каким образом можно изменять модификатор доступа при переопределении метода в наследнике?

Можно только расширять - Метод или поле нельзя сделать менее видимым (Принцип подстановки Барбары Лисков)

> Что такое Dynamic Proxy?

Механизм, который позволяет создавать объект, реализующий необходимые нам интерфейсы во время исполнения программы (динамически), не создавая для него отдельного класса.  

> Какой метод переводит поток в режим ожидания?

sleep()

> Какое назначение метода load() класса Session

Возвращает прокси вместо реального объекта entity из БД по его идентификатору

> Нужен ли Web Container для запуска Spring Boot приложения?

Нет, WC не обязателен - Spring Boot приложение не требует наличия Web Container (контейнера сервлетов) для своего запуска, так как встроенный сервер (например, Tomcat, Jetty) уже включен в состав Spring Boot.

> Какой файл определяет соответствие между путями URL и сервлетами, который эти URL будут обрабатывать?

web.xml

> Что нового в Spring Framework 5.0?

Functional Web Framework, Kotlin и и поддержка реактивного программирования.

> Какой метод переведет состояние потока из Running в Runnable?

yield(); - Метод yield() используется для перевода потока из состояния Running (выполняется) в состояние Runnable (готов к выполнению).

> Для чего необходима денормализация в реляционных базах данных?

Повышения производительности - Денормализация - это метод оптимизации базы данных, при котором мы добавляем избыточные данные в одну или несколько таблиц. 
Это может помочь нам избежать дорогостоящих объединений в реляционной базе данных.

> Как получить путь к каталогу src/test/resources в JUnit?

С помощью ClassLoader
```java
ClassLoader classLoader = getClass().getClassLoader();
File file = new File(classLoader.getResource("somefile").getFile());
System.out.println(file.getAbsolutePath());
```

> Для чего нужен метод finalize()?

Метод finalize() в Java является методом, который вызывается сборщиком мусора (garbage collector) перед уничтожением объекта. 
Он предназначен для выполнения завершающих действий перед освобождением ресурсов

> Условия переопределения equals()?

1. Рефлексивность: Это означает, что объект должен быть равен самому себе. То есть для любого объекта x, выражение x.equals(x) должно возвращать true.
2. Симметричность: Это означает, что если объект x равен объекту y, то и объект y должен быть равен объекту x. То есть для любых двух объектов x и y, если x.equals(y) возвращает true, то и y.equals(x) также должен возвращать true.
3. Транзитивность: Это означает, что если объект x равен объекту y, а объект y равен объекту z, то объект x также должен быть равен объекту z. То есть для любых трех объектов x, y и z, если x.equals(y) и y.equals(z) возвращают true, то и x.equals(z) должен возвращать true.

> Для чего нужна @PreAuthorize?

Аннотация `@PreAuthorize` используется в Spring Security для указания, что метод должен быть выполнен только в том случае, если пользователь имеет определенные разрешения.
Она позволяет определить ограничение доступа на уровне метода, на основе выражения Spring Expression Language (SpEL), которое оценивается во время выполнения.
Вот пример использования `@PreAuthorize`:
```java
@PreAuthorize("hasRole('ROLE_ADMIN')")
public void deleteProduct(Long id) {
    // Код для удаления продукта
}
```

> Какой в джаве основной ClassLoader?

Bootstrap ClassLoader

> Какая аннотация более приоритетнее? @Qualifier или @Primary?

@Primary

> Можем ли мы выполнить нативный запрос SQL (sql native) в Hibernate?

При помощи аннотации @Query

> К объекту какого класса привязан кеш второго уровня в Hibernate?

Кеш второго уровня в Hibernate привязан к объекту SessionFactory.

> Для чего нужен интерфейс Callable?

Интерфейс Callable в Java представляет собой функциональный интерфейс, который определяет метод call(), возвращающий объект Future.
Интерфейс `Callable` часто используется в ситуациях, когда задача, которую необходимо выполнить, является длительной или сложной, и требуется получить результат выполнения этой задачи. 

> В чём разница между @Component, @Service и @Repository аннотациями?

`@Component` является базовой аннотацией, а `@Service` и `@Repository` являются более специализированными аннотациями, которые наследуют от `@Component`.

> Что вернет метод session.load(), если в БД нет подходящей записи?

Если после выполнения запроса соответствующая запись все еще не найдена, Hibernate сгенерирует исключение ObjectNotFoundException.

> Для чего нужен метод intern() класса String?

Метод `intern()` принудительно добавляет строку в пул строк и возвращает ссылку на объект `String` из пула. Если строка уже существует в пуле, `intern()` возвращает ссылку на существующую строку.
