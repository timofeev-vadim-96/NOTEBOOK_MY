# СУБД и SQL

[Назад](./СОБЕСЫ.md)    

> Что такое шардирование?

Шардирование (sharding) — это процесс горизонтального разделения данных на несколько частей («шардов»), размещаемых на разных физических устройствах (серверы, узлы). Цель шардинга заключается в распределении нагрузки. Например, данные пользователя из Владивостока лучше хранить на востоке, чем на сервере в Москве.

> Свойства транзакций?  

`ACID` 
1. Атомарность - все или ничего
2. Консистентность - результат транзакции становится доступен всем потребителям по окончании транзакции
под консистентностью понимает переход из одного состояния в другое (счет с деньгами до и после перевода)
3. Изоляция - транзакции друг на друга никак не влияют
4. Дурабилити - результат выполнения транзакции будет сохранен и откату уже не подлежит

> Уровни вложенности транзакций (propagation)?  

1. Propagation.**REQUIRED** (дефолтное) - если нет транзакции, то она будет создана. Если произойдет Rollback, то откатятся обе 
2. Propagation.**REQUIRED_NEW** - создание новой транзакции в вызываемОМ методе. Транзакция в вызывающЕМ будет приостановлена и возобновлена по завершению вложенной. (пример: попытка списания денег со счета должна быть зафиксирована даже тогда, когда списание в итоге не произошло)
3. Propagation.**SUPPORT** - если есть транзакция над вызывающим методом - то будет исполнена, если нет - то метод исполнится без транзакции (БЕСПОЛЕЗНАЯ)
4. Propagation.**MANDATORY** - если нет транзакции, то будет брошено ИСКЛЮЧЕНИЕ (исп. на методах Репозитория)
5. Propagation.**NOT_SUPPORTED** - в момент выполения метода приостанавливаются любые внешние транзакции, чтобы тело метода было выполнено **нетранзакционно**
6. Propagation.**NEVER** - если испольуется транзакция, то бросается ИСКЛЮЧЕНИЕ
7. Propagation.**NESTED** - запускается во внутренней транзакции, если текущая существует (НА УРОВНЕ `БД`)

> Уровни изолиции транзакций (isolation)?

1. **Read Uncommitted**: транзакции могут видеть нефиксированные изменения, сделанные другими транзакциями.
2. **Read Committed**: транзакция может читать только зафиксированные изменения.
3. **Repeatable Read**: если транзакция прочитала строку, никакая другая транзакция не может изменить её до завершения первой транзакции.
4. **Serializable**: самый строгий уровень изолированности. Транзакции выполняются так, как если бы они выполнялись последовательно, не допуская пересечения.

> Что такое кластеризованный индекс, и сколько их может быть в одной таблице?

Кластеризованный индекс — это особый вид индекса в базе данных, при котором физические строки таблицы хранятся в отсортированном порядке согласно ключу индекса. Таблица может содержать ровно один кластеризованный индекс. Причина проста: данные могут быть физически отсортированы лишь по одному признаку. Таблицы без первичного ключа могут вообще не иметь кластеризованного индекса, но чаще всего первичный ключ становится именно таким индексом.

> Какое значение имеет порядок объявления столбцов в составном индексе?

Первый столбец должен  максимально ограничивать последующую выборку. Допустим, мы имеем два столбца: А и Б. Значению по столбцу А соответствует 10 записей, а по стобцу Б 3 записи. В таком случае, первым в составном индексе нужно объявлять столбец Б.

> Любая ли операция SQL может содержаться в транзакции?

Операции, которые могут быть частью транзакции, это обычно операции INSERT, UPDATE и DELETE, то есть операции с манипуляцией данными.  
Операции, которые обычно не могут быть частью транзакции, это операции DDL, такие как CREATE, ALTER, DROP, так как если мы выполним, допустим, операцию по созданию таблицы, то она в рамках транзакции не может быть отменена, даже если мы захотим откатить транзакцию.   
Также частью транзакции не могут быть команды COMMIT и ROLLBACK, которые, помимо Java также есть в SQL, так как они сами по себе управляют данной транзакцией.

> В чем разница между PROPAGATION_REQUIRED и PROPAGATION_REQUIRES_NEW? Когда использовать каждый из них?

PROPAGATION_REQUIRED: Если существующая транзакция есть, текущий метод присоединяется к ней. Если транзакции нет, создается новая. Это наиболее распространенный вариант.
PROPAGATION_REQUIRES_NEW: Всегда создается новая, независимая транзакция. Существующая транзакция приостанавливается, а новая запускается. После завершения новой транзакции (вне зависимости от успешности), возобновляется старая. Это полезно, если вы хотите изолировать часть работы от возможных откатов в основной транзакции

> Для чего необходима денормализация в реляционных базах данных?

Повышения производительности - Денормализация - это метод оптимизации базы данных, при котором мы добавляем избыточные данные в одну или несколько таблиц. 
Это может помочь нам избежать дорогостоящих объединений в реляционной базе данных.

> Что такое нормализация в реляционных базах данных?

Устранение избыточности данных.

 > На какие столбцы нужно навесить индексы в базе?

* На столбцы, которые часто используются в выборке по условию WHERE
* На столбцы, которые часто объединяются в JOINах, это значительно ускорит процесс объединения
* На столбцы, которые часто используются в выборке по условиям GROUP BY и ORDER BY