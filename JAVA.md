# JAVA - кроссплатформенный язык с обратной совместимостью всех версий   
Преподаватель:
  * (лекции) - Сергей Камянецкий  
  * (семинары) - Александр Леонидов  

Самая удобная среда разработки - **IntelliJ IDEA**  

несколько **правил, относительно java**:

1. Названия классов в java - существительные с большой буквы верблюжьей нотацией: CamelCase,   
2. названия методов - отглагольные, с маленькой буквы, верблюжьей нотацией: getUserById.  
3. Названия переменных - с маленькой буквы, верблюжьей нотацией: maxCount  
4. названия пакетов в java существительные, всегда с маленькой буквы и в одно слово.  
5. Если логика классов внутри пакета не позволяет назвать все в одно существительное, надо вложить один пакет в другой  
6. Называть классы по их функционалу  

Минимальная единица языка программирования JAVA - класс.   
100% случаев имя класса = имя файла. (по умолчанию)  
Место, с которого начинается выполнение программы - точка входа. Она обозначается функцией main.  

Базовой единицей в итоге является класс, который в себе содержит метод с названием **main**, который принимает в себя обязательно массив строк. 

Любой метод в JAVA должен быть частью класса.  


### Снипеты  

Чтобы быстро писать код - лучше учить **снипеты**:
sysout/sout = print;  
psvm - public static void main;  

Чтобы запустить скомпиллировать файл:
  * кнопка
  * в консоль: java filename.java  

Многострочный комментарий:  
/**

Однострочный комментарий: (как в C#)  
//  

Типы данных:
1. Ссылочные (относятся к классам) 
  * массивы  
2. Примитивные (примитивы)
  * boolean
  * int (занимает 4Б)  
    * при объявлении больших чисел их разряды можно разделять нижним подчеркиванием: a = 123_123_123  
  * short (более мелкий тип, хз зачем)
  * long 
  * float, double
    * объявление: float n = 2.7f; f - обязательно. почему так? потому что изначально вещественное число 
    воспринимается как тип double. Для double, соответственно, этого можно не делать(но можно, суффикс D)  
  * char - отдельный символ 
  * byte (хранит значение до 127)  
3. доп.  
* String - точно не примитивный тип данных, сколько занимет памяти на выходе не ясно(условно 2Б на символ, но
сколько символов в итоге?)
  * * Чтобы обратиться к элементу строки: s.charAt(0)   
* var - неявная типизация  

В JAVA у типов данных есть **Классы-обертки**: 
* Integer и т.д. Вызов всего функционала проиходит через них. Integer.MAX_VALUE
* Short
* Long
* Byte
* Float
* Dobule
* Character
* Boolean

* Чтобы вывести тип данных: 
public static String getType(Object o) {
        return o.getClass().getSimpleName();
        } 

Логические операторы - как в C#. 
Также есть и обычные и побитовые. В общем случае используем:
  * && - и
  * || - или  
  * ^ - возвращает True когда **строго** одно из значений - истина. 2 - нельзя, 0 - нельзя. только 1.  
  * ! - оператор отрицания. как not in python  

Побитовые операции:  (вряд ли пригодится, мб для написания функций корней и т.д., но очень вряд ли)
  * побитовые сдвиги <<, >>, ^, |, &  
  Интересно: в отличие от бытрых логических операторов, побитовые в любом случае проверяют все условия, тогда
  когда быстрые - в случае не выполнения одно из условий - выдают сразу false(и это удобно)  
  Пример:  
  a = 8  (1000 - в бит виде)
  a << 1  
  10000 (16)  
  * побитовое или |
  Пример: 2 | 5
  Сравнивает
  101
  010
  111 - в итоге = 7  
  * побитовое и &  
  Пример: 2 | 5
  Сравнивает
  101
  010
  000 - в итоге = 0 
  * побитовое строго или ^
  Пример: 2 | 5
  Сравнивает
  101
  010
  111 - в итоге = 7  

Объявление и инициализация переменных:  
Можно просто объявить переменную:
  * string n
  Однако в том случае, если далее она не будет инициализирована, то вызовет ошибку

В общем случае лучше всегда сразу ее инициализировать
  * string n = null  

Операции Java:  
/ - нужно смотреть разницу для интовых и вещественных  
вспоминаем:
++ - инкремент
-- - декримент  
могут быть постфиксными a++, и префиксными ++a  

! По поводу выполнения операций - важно обращать внимание на **приоритет операции**:
например: print(a++) - выведет старое значение а, а уже после увеличит его значение  
        выход: print(++a) - мы поменяли приоритет операции  

* Чтобы объявить массив:  
    * int [] arr = [10]  
    * int [] arr = [] {1,2,3,4}  
    * без инициализации:  
        * int [] arr;
        * int arr [];

* Чтобы объявить думерный массив:  
    * int [] arr [] = new int [3] [5];  
    * int [][] arr = new int [3] [5]; //массивы массивов, хз что значит;  

* Преобразования:  
    * неявное:  
    int i = 123; // i = 123
    double d = i; // d = 123.0  

    d = 3.141;
    i = (int)d; // 3  

* Распарсить строку в байты:  
  * byte b = Byte.parseByte("127");  

* Распарсить строку в дабл/int:  
  * Double.parseDouble(str);  
  * Scanner.nextDobule;  

* Для получения данных из терминала:  
  import java.util.Scanner;

* Вывести строку через маску (спецификатор):  
String S = String.format("%d + %d = %d \n", a, b, c);  
        System.out.printf("%d + %d = %d \n", a, b, c);  
        System.out.println(S);  

Виды спецификаторов:  
%d: целочисленных значений  
%x: для вывода шестнадцатеричных чисел  
%f: для вывода чисел с плавающей точкой  
%e: для вывода чисел в экспоненциальной форме,  
например, 3.1415e+01  
%c: для вывода одиночного символа  
%s: для вывода строковых значений  

* Количество знаков после запятой:  
float pi = 3.1415f;  
System.out.printf("%.2f\n", pi); // 3,14  

* Тернарный оператор:  
int min = a < b ? a : b; // если true - a, false - b; 

* Циклы:  
  * при работе с foreach мы работаем с item (как бы копия элементов i в массиве), так что присвоить новое значение  
  элементу массива с помощью foreach не получится.  

> package - пакет, у которого есть своя область видимости  

* Static в объявлении метода: Если метод статик, то он принадлежит к классу, а если без статика, то к экземпляру класса.  
Например:  
public class Main {  
    public static void main(String[] args) {  
        Task1 task1 = new Task1();  
        Task1.Hello();  // обращаемся к классу. без статики нужно будет обращаться к экземпляру класса task1  
    }  
}  

* Чтобы вывести текущее время и дату:  
System.out.println(LocalDateTime.now());  

* Изменить размер шрифта кода: Alt+Shift+./Ю  

* Чтобы считать текст с консоли:  
Scanner scanner = new Scanner(System.in); // переменная типа сканер  
String data = scanner.next();  
  * чтобы работать со сканнером в VSC:  
  import java.util.Scanner;  

* Чтобы запушить на GitHub:  
VCS на панели инструментов -> Share project... 

* Чтобы построить строку с помощью стринг-билдера:  
StringBuilder sb = new StringBuilder();  
for (int i = 0; i < 1_000_000; i++) {  
sb.append("+");  
}  

**Работа со строками** - при сборке строки лучше использовать StringBuilder, при разборке/поиске - String.  (От этого зависит скорость р-ты)  

**Функции для работы со строками:**  
concat(): объединение строк  
valueOf(): преобразует Object в строковое представление (завязан на toString())  
join(): объединяет набор строк в одну с учетом разделителя  //String.join("", arg)
charAt(): получение символа по индексу  
indexOf(): первый индекс вхождения подстроки  
lastIndexOf(): последний индекс вхождения подстроки  
startsWith()/endsWith(): определяет, начинается/заканчивается ли строка с подстроки  
replace(): замена одной подстроки на другую  
trim(): удаляет начальные и конечные пробелы  
substring(): возвращает подстроку, см.аргументы  
toLowerCase()/toUpperCase(): возвращает новую строку в нижнем/верхнем регистре  
сompareTo(): сравнивает две строки  
equals(): сравнивает строки с учетом регистра  
equalsIgnoreCase(): **сравнивает строки без учета регистра**  
regionMatches(): сравнивает подстроки в строках  

* Чтобы привести StringBuilder(стрингбилдер) в строку:  
newStroke.toString()  

* Чтобы привести строку в массив:  
String [] arr = inputString.split("");  


* Чтобы вывести (распечатать) массив:  
System.out.println(Arrays.toString(arr));  

* Чтобы вывести (распечатать) ArrayList:  
System.out.println(Arrays.toString(arr.toArray()));  

* Чтобы сравнивать строки:  
stroke1.equals(stroke2)  

* Чтобы пробежаться/пройтись по строке:     
for (char c: arg.toCharArray()){   
  ...  
}  

**Работа с файлами:**  
Для работы нужно:  
import java.io.File;  //библиотека для работы с файлами.
File <имя> = new File(<полный путь к файлу>);
File f1 = new File("file.txt"); // относительный путь - маршрутизация от той папки, в рамках которой запущена программа. 
File f2 = new File("/Users/sk/vscode/java_projects/file.txt"); //абсолютный путь  

String pathProject = System.getProperty("user.dir") //предполагаю, что для получения пути к пользователю (мб разный в разных оп. сист)  
String pathFile = pathProject.concat("/file.txt"); //получить путь к файлу  
File f3 = new File(pathFile);  //создать новый файл  
System.out.println(f3.getAbsolutePath ());  //здесь очевидно абсолютный путь к файлу

Основные ошибки при работе с файлами:  
1. Неправильный путь;  
2. Отсутствие какой-либо папки;  
3. Отсутствие файла;  
4. Неверный тип файла;  
5. Слишком большой файл, может не хватить памяти, чтобы весь файл одновременно выгрузить;  
6. Файл пустой;  
7. Битый/поврежденный файл (например, не докаченный из интернета);  
8. Файл открыт сторонней программой (вирус/антивирус)...  

**Обработка исключений/ошибок:**   
try {  // при записи файла - запись нужно останавливать. Чтобы этого не делать или не забыть об этом:  
пишем создание файла в скобках после try (код)   
Код, в котором может появиться ошибка  
} catch (Exception e) {  // блок catch, если есть какое-то проверяемое исключение  
// на разные ошибки могут быть разные catch  
// в скобках кетча можно прописть через | и другие ошибки, которые будут одинаково обрабатываться  
Обработка, если ошибка случилась  
}  
finally {  // блок finally - не обязательный  
Код, который выполнится в любом случае  
}  

**Функции для работы с файлами:**  
isHidden(): возвращает истину, если каталог или файл является скрытым  
length(): возвращает размер файла в байтах  
lastModified(): возвращает время последнего изменения файла или каталога  
list(): возвращает массив файлов и подкаталогов, которые находятся в каталоге  
listFiles(): возвращает массив файлов и подкаталогов, которые находятся  
в определенном каталоге  
mkdir(): создает новый каталог  
renameTo(File dest): переименовывает файл или каталог  

Полное имя файла - это весь путь к нему, включая сам файл.  
Путь к файлу - путь до папки, в которой лежит файл. 

* Чтобы **создать новый файл**:  
File file = new File("test.txt");  
            file.createNewFile();  

Object  
Пример задания объекта:  
public class Ex01_object {
 public static void main(String[] args) {
 Object o = 1; GetType(o); // java.lang.Integer
 o = 1.2; GetType(o); // java.lang.Double
 }
 static void GetType(Object obj) {
 System.out.println(obj.getClass().getName());
 }
}

**Добавить элемент в список:**  
list.add(numb or smth else)  
list.add(index, data);  // по индексу  
  * если длина списка меньше, чем номер индекса, то этот список нужно, как минимум, заполнить пустыми значениями  
  .add(null); мб в цикле  

Создать список:  
ArrayList<Integer> list1 = new ArrayList<Integer>();  
ArrayList<Integer> list2 = new ArrayList<>();  
ArrayList<Integer> list3 = new ArrayList<>(10);  
ArrayList<Integer> list4 = new ArrayList<>(list3);  
List<Integer> list = List.of(1,2,3); - будет иммутабельным  

Функции для коллекций (напр. списков):  
add(args) – добавляет элемент в список ( в т.ч. на нужную позицию)  
get(pos) – возвращает элемент из списка по указанной позиции  
indexOf(item) – первое вхождение или -1  
lastIndexOf(item) – последнее вхождение или -1  
remove(pos) – удаление элемента на указанной позиции и его возвращение  
set(int pos, T item) – gjvtoftn значение item элементу, который находится на позиции pos  
void sort(Comparator) – сортирует набор данных по правилу  
subList(int start, int end) – получение набора данных от позиции start до end  
clear() – очистка списка  
toString() – «конвертация» списка в строку  
Arrays.asList – преобразует массив в список  
containsAll(col) – проверяет включение всех элементов из col  
removeAll(col) – удаляет элементы, имеющиеся в col  
retainAll(col) – оставляет элементы, имеющиеся в col  
toArray() – конвертация списка в массив Object’ов  
toArray(type array) – конвертация списка в массив type  
List.copyOf(col) – возвращает копию списка на основе имеющегося  
List.of(item1, item2,...) – возвращает неизменяемый список  
  * List.of('S', 'e', 'r', 'g', 'e', 'y');


StringBuilder пример:  
import java.util.Arrays;  
import java.util.List;  
public class Ex005_ArraysMethod {  
 public static void main(String[] args) {  
 StringBuilder day = new StringBuilder("28");  
 StringBuilder month = new StringBuilder("9");  
 StringBuilder year = new StringBuilder("1990");  
 StringBuilder[] date = { day, month, year };  
 List<StringBuilder> d = Arrays.asList(date);  
 System.out.println(d);  
 }  


**Цикл foreach в JAVA:**  
for(int item: list){  
  sout..(item)  
}  


Итератор:  
Получение итератора с целью более гибкой работы с данными URL  
Интерфейс Iterator<E>. Итератор коллекцией. Iterator занимает место  
Enumeration в Java Collections Framework. Итераторы отличаются от  
перечислений двумя способами:  
Итераторы позволяют вызывающей стороне удалять элементы из  
базовой коллекции во время итерации с четко определенной  
семантикой.  
hasNext(), next(), remove()  # базовый функционал
ListIterator<E> URL  
hasPrevious(), E previous(), nextIndex(), previousIndex(), set(E e), add(E e)  

**Random рандом**:  
Random rd = new Random(); - переменная типа Rand..  
for...
list.app(rd.nextInt(1,11)); - добавляем рандомные числа в список от 1 до 10  

* Чтобы увеличить экран IndIdea:  Alt + Shift + .  

* Отсортировать список или массив:  
Collections.sort(list);    

* Чтобы засечь время:  
long startTime = System.currentTimeMillis();  
System.out.println(System.currentTimeMillis()-startTime);  

* Чтобы удалить элемент списка:  
resList.remove(0);  

* Проверить на наличие типа данных:    
for (Object o : list){  
  if (o instanceof Integer)...  
}  

* Задать переменную на уровне класса:  
privat static final ...переменная... name = ...;  

LinkedList  
Представляет собой двусвязный список.  
Список – гибкая структура данных, позволяющая легко менять свой  
размер. Элементы доступны для вставки или удаления в любой позиции.  

* Чтобы **создать LinkedList** (двусвязный список):  
 LinkedList<Integer> ll = new LinkedList<Integer>();  

* **Чтобы перевернуть коллекцию (список):**   
Collections.reverse(inputLinkList);  

* Чтобы создать очередь 
1. Queue<Integer> qu = new LinkedList<>();  //принцип FIFO - first in first out  (как очередь к кассе)   
2. PriorityQueue - Наибольший приоритет будет у наименьшего элемента  
  * Чтобы создать приоритетную очередь:  
  PriorityQueue<Integer> pq = new PriorityQueue<>();  
3. Deque - double ended queue - можно добавлять/извлекать данные как из начала, так с конца 
> Чтобы  данные выводились с конца, в Deque нужно не добавлять (add), а пушить!!!!(push) - кладем наверх   

* Чтобы создать Deque:  
ArrayDeque<String> dequeDataBase = new ArrayDeque<>();  

**Функционал очереди Deque:**   
* deque.addFirst(1); deque.addLast(2);  
* deque.removeLast(); deque.removeLast();  
* deque.offerFirst(1); deque.offerLast(2);  
* deque.pollFirst(); deque.pollLast();  
* deque.getFirst(); deque.getLast();  
* deque.peekFirst(); deque.peekLast();  
4. Stack - Lust in first out (как стопка книг) // не используется более, исп-ся ArrayDeque  
[работа со Stack](https://github.com/ZiganshinIB/GB_Seminar_1/blob/master/src/lesson4/task/GBStack.java "Stack")  


* Чтобы привести к числу: Integer.parseInt(argument);  

* Чтобы извлечь элемент из очереди:  
name.poll();  

* Чтобы вывести макс, мин, среднее значение из списка:  
int a = arr.stream().mapToInt(Integer::intValue).max().orElse(Integer.MAX_VALUE);  
double a = arr.stream().mapToDouble(Integer::doubleValue).average().orElse(Double.MAX_VALUE); 

* Алгоритм для работы с json:  
1. Создаем не обычный проект java, a mavan or gradle (сборщики проектов) gradle - более современный;  
2. В Browser - "json simple maven dependency"  
ссылка : https://mvnrepository.com/artifact/com.googlecode.json-simple/json-simple/1.1  
3. вкладка Gradle - и тупо копировать в файл ссылку, указанную в окошке.  
Если файл Maven:  
помещать внутри <dependencies> вначале и в конце кода  

* **Форматирование автоматическое:**  
ctrl + alt + l  

**Map – это множество коллекций, работающих с данными**  
по принципу <Ключ / Значение>.  // ключ - уникальное значение (как словари в питоне), 
сами "Значения" могут повторяться  
Ключевые особенности:  
● ускоренная обработка данных;  
* значения могут быть null - пустые ссылки. это так называемые "не валидные" данные  
● порядок добавления не запоминается.  

В HashMap элементы располагаются как угодно и могут менять свое положение.  
* ! очень не экономна по памяти, т.к. испльзует в своей основе хэш-таблицы(ничто иное, как массивы).  
Сильно раздвувает хэш-таблицу с целью резерва ячеек памяти для мудующих элементов  (+80% при приближении к заполняемости)  
* Но работает очень быстро (O(1))  

> Хранение данных в HashMap происходит как в классических списках/как в сбаланиросанных деревьях  

* Чтобы создать Map:  
Map<Integer, String> db = new HashMap<>(); //где Integer - тип ключа, String - тип значения  
Map<Integer, String> db = new HashMap<>(9);  // изначальный размер из 9 элементов  
Map<Integer,String> map3 = new HashMap<>(9, 1.0f); // конструктор, где 9 - количество элементов, 1.0 - это
количество процентов, при заполнении которых будет происходить условное удовение пространства ХэшМэпа  

* Чтобы что-то добавить в Map:  
db.put(1, "один");  
db.putIfAbsent(1, "один"); //проверяет свободен ли такой ключ и записывает 

* Чтобы создать HashMap измассива:  
var a = new HashSet<>(Arrays.asList(1,2,3,4,5,6,7));  

* Чтобы сделать копию/скопировать HashMap:  
var u = new HashSet<Integer>(a)  

**Функции HashMap:** 
put(K,V) – добавить пару если или изменить значение,если ключ имеется.  
putIfAbsent(K,V) – произвести добавление если ключ не найден.  
get(K) - получение значения по указанному ключу.  
remove(K) – удаляет пару по указанному ключу.  
containsValue(V) – проверка наличия значения.  
containsKey(V) – проверка наличия ключа.  
keySet() – возвращает множество ключей.  
values() – возвращает набор значений.  

* Чтобы заполнить / добавить элементы в мапу Map:  
  * map = Map.of('{', '}', '<', '>', '[', ']','(', ')');  
  * map = Map.ofEntries(Map.entry('{', '}'), Map.entry('(', ')'));  
 
TreeMap - коллекция типа map (словарь), в которой происходит сортировка по значению ключа. При этом, 
необходимо как-то описывать логику сортировки, т.к. ключ не обязательно int... TODO Хранит данные структурой (в виде дерева). По памяти использует ровно столько ячеек, сколько имеет элементов.  Работает (O(log N)) 
* null быть не может   

* **Чтобы перевернуть TreeMap**:  
static Map<Integer, String> romanArabian = new TreeMap<>(Collections.reverseOrder());

* Высотой дерева - называетя количество его уровней  

* Чтобы создать TreeMap:  
TreeMap<Integer,String> tMap = new TreeMap<>();

**Функции TreeMap:**  
put(K,V) – добавить пару если или изменить значение,если ключ имеется.  
get(K) - получение значения по указанному ключу.  
remove(K) – удаляет пару по указанному ключу.  
descendingKeySet(V) возвращает множество ключей.  
descendingMap() показать в обратном порядке. 
tailMap() показать больше, чем. 
headMap() показать меньше, чем. 
lastEntry()  
firstEntry()  


> Hash-функции, это те же функции, под копотом которых имеются какие-то условия. 

* Чтобы пробежаться по значениями HashMap:  
for (var item : db.entrySet()) {  
 System.out.printf("[%d: %s]\n", item.getKey(), item.getValue());  
 }  
* for(Map.Entry<Integer, String> entry: db.entrySet()){  
 System.out.printf("[%d: %s]\n", item.getKey(), item.getValue());  
 }  

* LinkedHashMap - коллекция типа Map, которая помнит порядок добавления элементов. НО при этом работает  
значительно медленнее своих собратьев.  

* Чтобы создать **LinkedHashMap**:  
Map<Integer,String> linkmap = new LinkedHashMap<>();  

* HashTable - коллекция типа Map. Является **устаревшей!**. Не знает про null. 

* * Чтобы создать HashTable:  
Map<Integer,String> table = new Hashtable<>();  

**Коллекции Set** - практически все тоже самое, но без значению поключу, только ключи:  
* HashSet  
* LinkedSet  
* SordedSet  
* NavigatableSet  
* TreeSet  

**Особенности Set**:  
● Коллекции, содержащие уникальные элементы.
● Быстрая работа с данными.
● «Основан» на Map’ах без пары.
● Порядок добавления не хранится.  
* Может содержать значение null.  

**Функции для работы с HashSet**:  
isEmpty() – проверка на пустоту.  
add(V) – добавление элемента в коллекцию.  
remove(V) – удаление элемента из коллекцию.  
contains(V) – проверка на включение элемента в коллекции.  
clear() – удаление всех элементов коллекции.  
size() – возвращает количество элементов коллекции.  
addAll(Coll) – объединение множеств.  // пример:  u.addAll(b)  
retainAll(Coll) – пересечение множеств.  
removeAll(Coll) – разность множеств.  
first()  
last()  
headSet(E)  
tailSet(E)  
subSet(E1, E2)   

* Функции для работы с LinkedHashSet:    
isEmpty() – проверка на пустоту.  
add(V) – добавление элемента в коллекцию.  
remove(V) – удаление элемента из коллекцию.  
contains(V) – проверка на включение элемента в коллекции.  
clear() – удаление всех элементов коллекции.  
size() – возвращает количество элементов коллекции.  


* Чтобы создать Set / HashSet:  
Set<Integer> set = new HashSet<>();  
* Создать Set из массива:  
Arrays.stream(array).collect(Collectors.toSet());  

* Чтобы создать TreeSet:  
var a = new TreeSet<>(Arrays.asList(1,7,2,3,6,4,5));  

# ООП  

> **Введение в создание собственных типов:**   
Java является объектно-ориентированным языком.  
Программа, написанная на Java, должна соответствовать  
парадигме объектно-ориентированного программирования.  
Следует понимать, что принципы ООП не просто определяют  
структуру программы. Это некий фундаментальный подход,  
с которым нам предстоит разобраться.  
**Спагетти-код** – код, в котором данные связаны с методами  
для их обработки и в итоге может получиться так, что отдельные  
ветви алгоритма переплетаются, образуя запутанный клубок,  
в котором невозможно разобраться  

Решение проблемы получило название **объектно-ориентированноепрограммирование**   
или объектно-ориентированное проектирование или ООП.  
При использовании данного подхода, упорядочивание кода базируется  
на объединении данных, с одной стороны, и методов для обработки этих  
данных, с другой стороны, в одно целое. Это «одно целое» в ООП называется  
**экземпляром класса.**  
Вся программа при этом имеет блочную структуру, что существенно упрощает  
анализ кода и внесение в него изменения.  
ООП – искусственный прием, в большинстве случаев не зависящий, от языка  
программирования.  

**промежуточные итоги:**  
* Если говорят, что разработка идет с использованием ООП – это говорит о том, что используются классы и экземпляры этих классов.  
* Каждый **экземпляр класса** определяется общим шаблоном, который называется **классом**.  
* В рамках класса задается общая структура, на основе которой затем создаются экземпляры.  
* Данные, относящиеся к классу, называются полями класса (ничто иное, как переменные, объявленные в теле класса), а код для их обработки — методами класса.  

**Примеры:**  
Автомобиль – Lada 2107 UIN 123123123, S/N 789789789  
Здание – Дом по адресу г.Москва ул. Ленина 21к1  
Ученик – Сергей Камянецкий, 51 МиИ, СмолГУ  
Мобильный телефон – Siemens CX60 IMEI 1234520032022  
Геометрическая фигура – додекаэдр  
Работник – Смиронова Т.В. 14.02.1994, ID 728, Компания GeekBrains  
Котики – Барсик  

* **Чтобы вывести форматированную строку:**  
return String.format("id: %d, sl: %s, fn: %n, ln: %l" id, salary, firstName, lastName);  

* **Чтобы поменять базовое поведение стандартных функций** - необходимо переписать их в теле класса. Тогда для его экземплятров поведение данной функции будет таким, как определили его мы.  

* **Переопределить hashCode** по 1 параметру:  
public int hashCode() {  
        return id;  
    }  

* **Переопределить equals:**  
public boolean equals(Object obj) {  
        Worker t = (Worker) obj;  
        return id == t.id && firstName == t.firstName;  
    }  

public boolean equals(Object obj) {   
        if (obj instanceof Cat)  
            return ((Cat)object).name.equals(this.name)  
        else return false;  
    }  

* **Переопределить toString**:  
public String toString() {  
        return String.format("id: %d, sl: %s, fn: %n, ln: %l" id, salary, firstName, lastName);  
    }  



Модификаторы видимости(доступа) полей:  
* **public** - только в классе  
* **private** - во всей программе   
* **protecred** - в классе и у его наследников  
* **static** - переменная(поле) станет принадлежать только классу, но не его экземплярам. Это значит, что доступ к этой переменной будет по всей программе, даже не являющимся экземплярами классов. (**стараться избегать**, потому что под нее в любом случае выделяются ячейки оперативной памяти + считается нарушением инкапсуляции)

**Конструктор** - это метод без названия с таким же именем, как класс. Все, за что отвечает конструктор - построение экземпляра класса.  
* В теле класса может быть 2 конструктора: пустой и заполненный(функциональный)  
  * пустой конструктор нужен для того, чтобы не прописывать каждый раз параметры, если эти параметры у экземпляров класса, по сути, одни и те же. Ниже пример.  
* Чтобы **создать конструктор автоматически**: alt + insert  
* super. - для вызова метода родительского класса  
* **экземпляр класса (объект) хранится в куче, ссылка на экзепляр класса (объект) хранится в стэке**.  
* минимальный конструктор: public Animal(){}; 


Пример **использования мин. конструктора** (когда параметры у всех экз. класса одинаковые). При этом произойдет неявная передача параметров в полнотелый конструктор из тела пустого конструктора:  
public Animal(){  
  this.legsCount = 4;     
  this.color = black;    
  this.type = Dog;  
};  

Можно создать **усеченный конструктор** (например здесь необх. передать цвет, ост. автоматически передастся в главный конструктор):  
public Animal(String color){  
  this.legsCount = 4;     
  this.color = color;    
  this.type = Dog;  
}; 

* **Класс** - это шаблон для экземпляров класса.  

**Пример конструктора**:  
public class Animal {  
    int legsCount;  
    String color;  
    String type;  
public Animal(int legsCount, String color, String type) {  
        this.legsCount = legsCount;  // this - буквально - возьми входящее значение legsCount и присвой это значение этому параметру  
        this.color = color;  
        this.type = type;  
    }  
}  

**ТОЛЬКО для private полей**!!:  
Гетр и Сетр: (вызываются через alt + insert):  
Пример:  
Animal cat = new Animal("cat");  
int legsCount = dog.getLegsCount; // в этом случае получаем значение конструктора по умолчанию (4);  
cat.setLegsCount(3); // изменяем стандартное значение на 3.  

**Пример создания экземпляра с помощью конструктора**:  
Animal dog = new Animal(4, "black", "Dog");  

* **Привести объект к экземпляру класса**:  
((Cat) object)  

* **Проверить принадлженость объекта к классу**:  
if (object instanceof Cat) // Cat - класс  

Как пишутся классы:  
1. поля  
2. коснтрукторы
3. методы

* @Override - значит, что в классе переопределяется стандартный метод. 
  * для вызова методов для переопределения - ctrl + o  

* Чтобы **перезагрузить Идею**, когда видит ошибки в коде там, где их нет:  
File -> Invalidate Caches -> invalidate and restart  



**Полезные ссылки:**  
1. канал для изучения JAVA - https://www.youtube.com/channel/UCK5d3n3kfkzlArMccS0TTXA  
