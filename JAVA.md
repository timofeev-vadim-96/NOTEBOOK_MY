# JAVA - кроссплатформенный язык с обратной совместимостью всех версий   
Преподаватель:
  * (лекции) - Сергей Камянецкий  
  * (семинары) - Александр Леонидов  

Самая удобная среда разработки - **IntelliJ IDEA**  

несколько **правила/rools, относительно java**:

1. Названия классов в java - существительные с большой буквы верблюжьей нотацией: CamelCase,   
2. названия методов - отглагольные, с маленькой буквы, верблюжьей нотацией: getUserById.  
3. Названия переменных - с маленькой буквы, верблюжьей нотацией: maxCount  
4. названия пакетов в java существительные, всегда с маленькой буквы и в одно слово.  
5. Если логика классов внутри пакета не позволяет назвать все в одно существительное, надо вложить один пакет в другой  
6. Называть классы по их функционалу  
7. Названия итерируемых объектов - с маленькой буквы в множественном числе без List, Set... типа ~illebleList~ - > 
illebles  
8. Main - в корневой папке программы, все остальное - по пакетам.  

Минимальная единица языка программирования JAVA - класс.   
100% случаев имя класса = имя файла. (по умолчанию)  
Место, с которого начинается выполнение программы - точка входа. Она обозначается функцией main.  

Базовой единицей в итоге является класс, который в себе содержит метод с названием **main**, который принимает в себя обязательно массив строк. 

Любой метод в JAVA должен быть частью класса.  


### Снипеты  

Чтобы быстро писать код - лучше учить **снипеты**:
sysout/sout = print;  
psvm - public static void main;  

Чтобы запустить скомпиллировать файл:
  * кнопка
  * в консоль: java filename.java  

Многострочный комментарий (документация Java):  
/**

Однострочный комментарий: (как в C#)  
//  

Типы данных:
1. Ссылочные (относятся к классам) 
  * массивы  
2. Примитивные (примитивы)
  * boolean
  * int (занимает 4Б)  
    * при объявлении больших чисел их разряды можно разделять нижним подчеркиванием: a = 123_123_123  
  * short (более мелкий тип, хз зачем)
  * long 
  * float, double
    * объявление: float n = 2.7f; f - обязательно. почему так? потому что изначально вещественное число 
    воспринимается как тип double. Для double, соответственно, этого можно не делать(но можно, суффикс D)  
  * char - отдельный символ 
  * byte (хранит значение до 127)  
3. доп.  
* String - точно не примитивный тип данных, сколько занимет памяти на выходе не ясно(условно 2Б на символ, но
сколько символов в итоге?)
  * * Чтобы обратиться к элементу строки: s.charAt(0)   
* var - неявная типизация  

В JAVA у типов данных есть **Классы-обертки**: 
* Integer и т.д. Вызов всего функционала проиходит через них. Integer.MAX_VALUE
* Short
* Long
* Byte
* Float
* Dobule
* Character
* Boolean

* Чтобы вывести тип данных: 
public static String getType(Object o) {
        return o.getClass().getSimpleName();
        } 

Логические операторы - как в C#. 
Также есть и обычные и побитовые. В общем случае используем:
  * && - и
  * || - или  
  * ^ - возвращает True когда **строго** одно из значений - истина. 2 - нельзя, 0 - нельзя. только 1.  
  * ! - оператор отрицания. как not in python  

Побитовые операции:  (вряд ли пригодится, мб для написания функций корней и т.д., но очень вряд ли)
  * побитовые сдвиги <<, >>, ^, |, &  
  Интересно: в отличие от бытрых логических операторов, побитовые в любом случае проверяют все условия, тогда
  когда быстрые - в случае не выполнения одно из условий - выдают сразу false(и это удобно)  
  Пример:  
  a = 8  (1000 - в бит виде)
  a << 1  
  10000 (16)  
  * побитовое или |
  Пример: 2 | 5
  Сравнивает
  101
  010
  111 - в итоге = 7  
  * побитовое и &  
  Пример: 2 | 5
  Сравнивает
  101
  010
  000 - в итоге = 0 
  * побитовое строго или ^
  Пример: 2 | 5
  Сравнивает
  101
  010
  111 - в итоге = 7  

Объявление и инициализация переменных:  
Можно просто объявить переменную:
  * string n
  Однако в том случае, если далее она не будет инициализирована, то вызовет ошибку

В общем случае лучше всегда сразу ее инициализировать
  * string n = null  

Операции Java:  
/ - нужно смотреть разницу для интовых и вещественных  
вспоминаем:
++ - инкремент
-- - декримент  
могут быть постфиксными a++, и префиксными ++a  

! По поводу выполнения операций - важно обращать внимание на **приоритет операции**:
например: print(a++) - выведет старое значение а, а уже после увеличит его значение  
        выход: print(++a) - мы поменяли приоритет операции  

* Чтобы объявить создать массив:  
    * int [] arr = new int [10]  
    * int [] arr = new int [] {1,2,3,4}  
    * int [] arr = {1,2,3,4}  
    * T [] temp = values;  
    * без инициализации:  
        * int [] arr;
        * int arr [];

* Чтобы **скопировать массив**:  
System.arraycopy(temp,0, values,0, temp.length);  temp - откуда, 0 - c какого элемента копируем, values - куда копируем, 0 - начиная на какую позицию копируем, temp.lenght - сколько всего элементов копируем(указываем длину массива, из которого копируем)  

* Чтобы объявить думерный массив:  
    * int [] arr [] = new int [3] [5];  
    * int [][] arr = new int [3] [5]; //массивы массивов, хз что значит;  

* Преобразования:  
    * неявное:  
    int i = 123; // i = 123
    double d = i; // d = 123.0  

    d = 3.141;
    i = (int)d; // 3  

* Распарсить строку в байты:  
  * byte b = Byte.parseByte("127");  

* Распарсить строку в дабл/int:  
  * Double.parseDouble(str);  
  * Scanner.nextDobule;  

* Для получения данных из терминала:  
  import java.util.Scanner;

* Чтобы получить текущую дату:  
this.year = LocalDate.now().getYear();  

* Вывести строку через маску (спецификатор):  
String S = String.format("%d + %d = %d \n", a, b, c);  
        System.out.printf("%d + %d = %d \n", a, b, c);  
        System.out.println(S);  

Виды спецификаторов:  
%d: целочисленных значений  
%x: для вывода шестнадцатеричных чисел  
%f: для вывода чисел с плавающей точкой  
%e: для вывода чисел в экспоненциальной форме,  
например, 3.1415e+01  
%c: для вывода одиночного символа  
%s: для вывода строковых значений  

* Количество знаков после запятой:  
float pi = 3.1415f;  
System.out.printf("%.2f\n", pi); // 3,14  

* Тернарный оператор:  
int min = a < b ? a : b; // если true - a, false - b; 

* Циклы:  
  * при работе с foreach мы работаем с item (как бы копия элементов i в массиве), так что присвоить новое значение  
  элементу массива с помощью foreach не получится.  

> package - пакет, у которого есть своя область видимости  

* **Static в объявлении** метода: *Если метод статик, то он принадлежит к классу, а если без статика, то к экземпляру класса.*  Статические вещи необходимо использовать по-минимуму, т.к. при запуске программы они как резервируют себе место в памяти до конца выполнения программы.  
+ внутри статики нельзя использовать нестатические аргументы и методы.  

Например:  
public class Main {  
    public static void main(String[] args) {  
        Task1 task1 = new Task1();  
        Task1.Hello();  // обращаемся к классу. без статики нужно будет обращаться к экземпляру класса task1  
    }  
}  

* Чтобы вывести текущее время и дату:  
System.out.println(LocalDateTime.now());  

* Изменить размер шрифта кода: Alt+Shift+./Ю  

* Чтобы считать текст с консоли:  
Scanner scanner = new Scanner(System.in); // переменная типа сканер  
String data = scanner.next();  
  * чтобы работать со сканнером в VSC:  
  import java.util.Scanner;  

* Чтобы запушить на GitHub:  
VCS на панели инструментов -> Share project... 

* Чтобы построить строку с помощью стринг-билдера:  
StringBuilder sb = new StringBuilder();  
for (int i = 0; i < 1_000_000; i++) {  
sb.append("+");  
}  

**Работа со строками** - при сборке строки лучше использовать StringBuilder, при разборке/поиске - String.  (От этого зависит скорость р-ты)  

**Функции для работы со строками:**  
concat(): объединение строк  
valueOf(): преобразует Object в строковое представление (завязан на toString())  
join(): объединяет набор строк в одну с учетом разделителя  //String.join("", arg)
charAt(): получение символа по индексу  
indexOf(): первый индекс вхождения подстроки  
lastIndexOf(): последний индекс вхождения подстроки  
startsWith()/endsWith(): определяет, начинается/заканчивается ли строка с подстроки  
replace(): замена одной подстроки на другую  
trim(): удаляет начальные и конечные пробелы  
substring(): возвращает подстроку, см.аргументы  
toLowerCase()/toUpperCase(): возвращает новую строку в нижнем/верхнем регистре  
сompareTo(): сравнивает две строки  
equals(): сравнивает строки с учетом регистра  
equalsIgnoreCase(): **сравнивает строки без учета регистра**  
regionMatches(): сравнивает подстроки в строках  

* Чтобы привести StringBuilder(стрингбилдер) в строку:  
newStroke.toString()  

* Чтобы привести строку в массив:  
String [] arr = inputString.split("");  


* Чтобы вывести (распечатать) массив:  
System.out.println(Arrays.toString(arr));  

* Чтобы вывести (распечатать) ArrayList:  
System.out.println(Arrays.toString(arr.toArray())); 

* вывести/распечатать LinkedList, а мб и все типы листов:  
list.forEach(System.out::println);  

* Чтобы сравнивать строки:  
stroke1.equals(stroke2)  

* Чтобы пробежаться/пройтись по строке:     
for (char c: arg.toCharArray()){   
  ...  
}  


* Метод для каскадного заполнения списка:  
public VetClinic addPet(Animal animal){  
        pets.add(animal);  
        return this;  
    }  
*Теперь можно будет добавлять животных через точку*


* Пройтись/перебрать/пробежаться по списку объектов:  
1. animals.forEach(a -> System.out.println(a));  

2.         for (Animal a: animals){  
            System.out.println(a);  
        }  

* С помощью перебора вызвать функцию у объекта  
3. animals.forEach(Animal::speak); //тоже самое, что animals.forEach(a -> a.speak());  

**Работа с файлами:**  
Для работы нужно:  
import java.io.File;  //библиотека для работы с файлами.
File <имя> = new File(<полный путь к файлу>);
File f1 = new File("file.txt"); // относительный путь - маршрутизация от той папки, в рамках которой запущена программа. 
File f2 = new File("/Users/sk/vscode/java_projects/file.txt"); //абсолютный путь  

String pathProject = System.getProperty("user.dir") //предполагаю, что для получения пути к пользователю (мб разный в разных оп. сист)  
String pathFile = pathProject.concat("/file.txt"); //получить путь к файлу  
File f3 = new File(pathFile);  //создать новый файл  
System.out.println(f3.getAbsolutePath ());  //здесь очевидно абсолютный путь к файлу

Основные ошибки при работе с файлами:  
1. Неправильный путь;  
2. Отсутствие какой-либо папки;  
3. Отсутствие файла;  
4. Неверный тип файла;  
5. Слишком большой файл, может не хватить памяти, чтобы весь файл одновременно выгрузить;  
6. Файл пустой;  
7. Битый/поврежденный файл (например, не докаченный из интернета);  
8. Файл открыт сторонней программой (вирус/антивирус)...  

---

**Обработка исключений/ошибок:**   
try {  // при записи файла - запись нужно останавливать. Чтобы этого не делать или не забыть об этом:  
пишем создание файла в скобках после try (код)   
Код, в котором может появиться ошибка  
} catch (Exception e) {  // блок catch, если есть какое-то проверяемое исключение  
// на разные ошибки могут быть разные catch  
  * catch (ClassCastException e){  // ошибка кастования, например, родительского класса Object к дочернему Cat  
            e.printStackTrace(); // метод вывода кода ошибки, есть у всех Exception  
        }  
  * catch (ClassCastException e){
            throw new RuntimeException(e); // время возникновения ошибки  
        }
  * } catch (NumberFormatException exception){  
            throw new NumberFormatException();  
        }  
// в скобках кетча можно прописть через | и другие ошибки, которые будут одинаково обрабатываться  
Обработка, если ошибка случилась  
 
finally {  // блок finally - не обязательный  
Код, который выполнится в любом случае  
}  

* **Свое исключение exception**:   
public class MathematicException extends Exception{  
    public MathematicException(String msg){  
        super(msg);  
    }    
}    

---

**Функции для работы с файлами:**  
isHidden(): возвращает истину, если каталог или файл является скрытым  
length(): возвращает размер файла в байтах  
lastModified(): возвращает время последнего изменения файла или каталога  
list(): возвращает массив файлов и подкаталогов, которые находятся в каталоге  
listFiles(): возвращает массив файлов и подкаталогов, которые находятся  
в определенном каталоге  
mkdir(): создает новый каталог  
renameTo(File dest): переименовывает файл или каталог  

Полное имя файла - это весь путь к нему, включая сам файл.  
Путь к файлу - путь до папки, в которой лежит файл. 

* Чтобы **создать новый файл**:  
File file = new File("test.txt");  
            file.createNewFile();  

Object  
Пример задания объекта:  
public class Ex01_object {
 public static void main(String[] args) {
 Object o = 1; GetType(o); // java.lang.Integer
 o = 1.2; GetType(o); // java.lang.Double
 }
 static void GetType(Object obj) {
 System.out.println(obj.getClass().getName());
 }
}

**Добавить элемент в список:**  
list.add(numb or smth else)  
list.add(index, data);  // по индексу  
  * если длина списка меньше, чем номер индекса, то этот список нужно, как минимум, заполнить пустыми значениями  
  .add(null); мб в цикле  

Создать список:  
ArrayList<Integer> list1 = new ArrayList<Integer>();  
ArrayList<Integer> list2 = new ArrayList<>();  
ArrayList<Integer> list3 = new ArrayList<>(10);  
ArrayList<Integer> list4 = new ArrayList<>(list3);  
List<Integer> list = List.of(1,2,3); - будет иммутабельным  (**нельзя сортировать или изменять!!!**)  

**Функции для коллекций** (напр. списков):  
add(args) – добавляет элемент в список ( в т.ч. на нужную позицию)  
get(pos) – возвращает элемент из списка по указанной позиции  
indexOf(item) – первое вхождение или -1  
lastIndexOf(item) – последнее вхождение или -1  
remove(pos) – удаление элемента на указанной позиции и его возвращение  
set(int pos, T item) – gjvtoftn значение item элементу, который находится на позиции pos  
void sort(Comparator) – сортирует набор данных по правилу  
subList(int start, int end) – получение набора данных от позиции start до end  
clear() – очистка списка  
toString() – «конвертация» списка в строку  
Arrays.asList – преобразует массив в список  
containsAll(col) – проверяет включение всех элементов из col  
removeAll(col) – удаляет элементы, имеющиеся в col  
retainAll(col) – оставляет элементы, имеющиеся в col  
toArray() – конвертация списка в массив Object’ов  
toArray(type array) – конвертация списка в массив type  
List.copyOf(col) – возвращает копию списка на основе имеющегося  
List.of(item1, item2,...) – возвращает неизменяемый список  
  * List.of('S', 'e', 'r', 'g', 'e', 'y');


StringBuilder пример:  
import java.util.Arrays;  
import java.util.List;  
public class Ex005_ArraysMethod {  
 public static void main(String[] args) {  
 StringBuilder day = new StringBuilder("28");  
 StringBuilder month = new StringBuilder("9");  
 StringBuilder year = new StringBuilder("1990");  
 StringBuilder[] date = { day, month, year };  
 List<StringBuilder> d = Arrays.asList(date);  
 System.out.println(d);  
 }  


**Цикл foreach в JAVA:**  
for(int item: list){  
  sout..(item)  
}  


Итератор:  
Получение итератора с целью более гибкой работы с данными URL  
Интерфейс Iterator<E>. Итератор коллекцией. Iterator занимает место  
Enumeration в Java Collections Framework. Итераторы отличаются от  
перечислений двумя способами:  
Итераторы позволяют вызывающей стороне удалять элементы из  
базовой коллекции во время итерации с четко определенной  
семантикой.  
hasNext(), next(), remove()  # базовый функционал
ListIterator<E> URL  
hasPrevious(), E previous(), nextIndex(), previousIndex(), set(E e), add(E e)  




**Random рандом**:  
Random rd = new Random(); - переменная типа Rand..  
for...
list.app(rd.nextInt(1,11)); - добавляем рандомные числа в список от 1 до 10  

* Чтобы увеличить экран IndIdea:  Alt + Shift + .  

* Отсортировать список или массив:  
Collections.sort(list);    
  * отсортировать объекты по какому-то критерию (например, возраст):  
  wList.sort((w1, w2) -> Integer.compare(w1.age, w2.age)); // но поле "age" должно быть public  


* Чтобы засечь время:  
long startTime = System.currentTimeMillis();  
System.out.println(System.currentTimeMillis()-startTime);  

* Чтобы удалить элемент списка:  
resList.remove(0);  

* Проверить на наличие типа данных:    
for (Object o : list){  
  if (o instanceof Integer)...  
}  

* Задать переменную на уровне класса:  
privat static final ...переменная... name = ...;  //final - значит, что переменную после объявления нельзя будет уже изменить. Пришло какое-то значение, и оно будет как константа.  

LinkedList  
Представляет собой двусвязный список.  
Список – гибкая структура данных, позволяющая легко менять свой  
размер. Элементы доступны для вставки или удаления в любой позиции.  

* Чтобы **создать LinkedList** (двусвязный список):  
 LinkedList<Integer> ll = new LinkedList<Integer>();  

* **Чтобы перевернуть коллекцию (список):**   
Collections.reverse(inputLinkList);  

* Чтобы создать очередь 
1. Queue<Integer> qu = new LinkedList<>();  //принцип FIFO - first in first out  (как очередь к кассе)   
2. PriorityQueue - Наибольший приоритет будет у наименьшего элемента  
  * Чтобы создать приоритетную очередь:  
  PriorityQueue<Integer> pq = new PriorityQueue<>();  
3. Deque - double ended queue - можно добавлять/извлекать данные как из начала, так с конца 
> Чтобы  данные выводились с конца, в Deque нужно не добавлять (add), а пушить!!!!(push) - кладем наверх   

* Чтобы создать Deque:  
ArrayDeque<String> dequeDataBase = new ArrayDeque<>();  

**Функционал очереди Deque:**   
* deque.addFirst(1); deque.addLast(2);  
* deque.removeLast(); deque.removeLast();  
* deque.offerFirst(1); deque.offerLast(2);  
* deque.pollFirst(); deque.pollLast();  
* deque.getFirst(); deque.getLast();  
* deque.peekFirst(); deque.peekLast();  
4. Stack - Lust in first out (как стопка книг) // не используется более, исп-ся ArrayDeque  
[работа со Stack](https://github.com/ZiganshinIB/GB_Seminar_1/blob/master/src/lesson4/task/GBStack.java "Stack")  


* Чтобы привести к числу: Integer.parseInt(argument);  

* Чтобы извлечь элемент из очереди:  
name.poll();  

* Чтобы вывести макс, мин, среднее значение из списка:  
int a = arr.stream().mapToInt(Integer::intValue).max().orElse(Integer.MAX_VALUE);  
double a = arr.stream().mapToDouble(Integer::doubleValue).average().orElse(Double.MAX_VALUE); 

* Алгоритм для работы с json:  
1. Создаем не обычный проект java, a mavan or gradle (сборщики проектов) gradle - более современный;  
2. В Browser - "json simple maven dependency"  
ссылка : https://mvnrepository.com/artifact/com.googlecode.json-simple/json-simple/1.1  
3. вкладка Gradle - и тупо копировать в файл ссылку, указанную в окошке.  
Если файл Maven:  
помещать внутри <dependencies> вначале и в конце кода 

* При работе с Gradle: 
чтобы импортировать библиотеку: в проекте Gradle в файл build.gradle в *Dependensies* добавить ссылку на нужную библиотеку  
Пример: (lambok gradle dependency)   compileOnly 'org.projectlombok:lombok:1.18.26'  
Когда ламбок подключен - сверху класса аннтоацию @Data or @Getter @Setter, для замены геттеров и сеттеров    

**Hotkeys/хоткеи**:  
* **Форматирование автоматическое:**  
ctrl + alt + l  
* **Переименовать переменную сразу везде**:  
Shift + F6  

**Map – это множество коллекций, работающих с данными**  
по принципу <Ключ / Значение>.  // ключ - уникальное значение (как словари в питоне), 
сами "Значения" могут повторяться  
Ключевые особенности:  
● ускоренная обработка данных;  
* значения могут быть null - пустые ссылки. это так называемые "не валидные" данные  
● порядок добавления не запоминается.  

В HashMap элементы располагаются как угодно и могут менять свое положение.  
* ! очень не экономна по памяти, т.к. испльзует в своей основе хэш-таблицы(ничто иное, как массивы).  
Сильно раздвувает хэш-таблицу с целью резерва ячеек памяти для мудующих элементов  (+80% при приближении к заполняемости)  
* Но работает очень быстро (O(1))  

> Хранение данных в HashMap происходит как в классических списках/как в сбаланиросанных деревьях  

* Чтобы создать Map:  
Map<Integer, String> db = new HashMap<>(); //где Integer - тип ключа, String - тип значения  
Map<Integer, String> db = new HashMap<>(9);  // изначальный размер из 9 элементов  
Map<Integer,String> map3 = new HashMap<>(9, 1.0f); // конструктор, где 9 - количество элементов, 1.0 - это
количество процентов, при заполнении которых будет происходить условное удовение пространства ХэшМэпа  

* Чтобы что-то добавить в Map:  
db.put(1, "один");  
db.putIfAbsent(1, "один"); //проверяет свободен ли такой ключ и записывает 

* Чтобы создать HashMap измассива:  
var a = new HashSet<>(Arrays.asList(1,2,3,4,5,6,7));  

* Чтобы сделать копию/скопировать HashMap:  
var u = new HashSet<Integer>(a)  

**Функции HashMap:** 
put(K,V) – добавить пару если или изменить значение,если ключ имеется.  
putIfAbsent(K,V) – произвести добавление если ключ не найден.  
get(K) - получение значения по указанному ключу.  
remove(K) – удаляет пару по указанному ключу.  
containsValue(V) – проверка наличия значения.  
containsKey(V) – проверка наличия ключа.  
keySet() – возвращает множество ключей.  
values() – возвращает набор значений.  

* Чтобы заполнить / добавить элементы в мапу Map:  
  * map = Map.of('{', '}', '<', '>', '[', ']','(', ')');  
  * map = Map.ofEntries(Map.entry('{', '}'), Map.entry('(', ')'));  
 
TreeMap - коллекция типа map (словарь), в которой происходит сортировка по значению ключа. При этом, 
необходимо как-то описывать логику сортировки, т.к. ключ не обязательно int... TODO Хранит данные структурой (в виде дерева). По памяти использует ровно столько ячеек, сколько имеет элементов.  Работает (O(log N)) 
* null быть не может   

* **Чтобы перевернуть TreeMap**:  
static Map<Integer, String> romanArabian = new TreeMap<>(Collections.reverseOrder());

* Высотой дерева - называетя количество его уровней  

* Чтобы создать TreeMap:  
TreeMap<Integer,String> tMap = new TreeMap<>();

**Функции TreeMap:**  
put(K,V) – добавить пару если или изменить значение,если ключ имеется.  
get(K) - получение значения по указанному ключу.  
remove(K) – удаляет пару по указанному ключу.  
descendingKeySet(V) возвращает множество ключей.  
descendingMap() показать в обратном порядке. 
tailMap() показать больше, чем. 
headMap() показать меньше, чем. 
lastEntry()  
firstEntry()  


> Hash-функции, это те же функции, под копотом которых имеются какие-то условия. 

* Чтобы пробежаться по значениями HashMap:  
for (var item : db.entrySet()) {  
 System.out.printf("[%d: %s]\n", item.getKey(), item.getValue());  
 }  
* for(Map.Entry<Integer, String> entry: db.entrySet()){  
 System.out.printf("[%d: %s]\n", item.getKey(), item.getValue());  
 }  

* LinkedHashMap - коллекция типа Map, которая помнит порядок добавления элементов. НО при этом работает  
значительно медленнее своих собратьев.  

* Чтобы создать **LinkedHashMap**:  
Map<Integer,String> linkmap = new LinkedHashMap<>();  

* HashTable - коллекция типа Map. Является **устаревшей!**. Не знает про null. 

* * Чтобы создать HashTable:  
Map<Integer,String> table = new Hashtable<>();  

**Коллекции Set** - практически все тоже самое, но без значению поключу, только ключи:  
* HashSet  
* LinkedSet  
* SordedSet  
* NavigatableSet  
* TreeSet  

**Особенности Set**:  
● Коллекции, содержащие уникальные элементы.
● Быстрая работа с данными.
● «Основан» на Map’ах без пары.
● Порядок добавления не хранится.  
* Может содержать значение null.  

**Функции для работы с HashSet**:  
isEmpty() – проверка на пустоту.  
add(V) – добавление элемента в коллекцию.  
remove(V) – удаление элемента из коллекцию.  
contains(V) – проверка на включение элемента в коллекции.  
clear() – удаление всех элементов коллекции.  
size() – возвращает количество элементов коллекции.  
addAll(Coll) – объединение множеств.  // пример:  u.addAll(b)  
retainAll(Coll) – пересечение множеств.  
removeAll(Coll) – разность множеств.  
first()  
last()  
headSet(E)  
tailSet(E)  
subSet(E1, E2)   

* Функции для работы с LinkedHashSet:    
isEmpty() – проверка на пустоту.  
add(V) – добавление элемента в коллекцию.  
remove(V) – удаление элемента из коллекцию.  
contains(V) – проверка на включение элемента в коллекции.  
clear() – удаление всех элементов коллекции.  
size() – возвращает количество элементов коллекции.  


* Чтобы создать Set / HashSet:  
Set<Integer> set = new HashSet<>();  
* Создать Set из массива:  
Arrays.stream(array).collect(Collectors.toSet());  

* Чтобы создать TreeSet:  
var a = new TreeSet<>(Arrays.asList(1,7,2,3,6,4,5));  

# ООП  

> **Введение в создание собственных типов:**   
Java является объектно-ориентированным языком.  
Программа, написанная на Java, должна соответствовать  
парадигме объектно-ориентированного программирования.  
Следует понимать, что принципы ООП не просто определяют  
структуру программы. Это некий фундаментальный подход,  
с которым нам предстоит разобраться.  
**Спагетти-код** – код, в котором данные связаны с методами  
для их обработки и в итоге может получиться так, что отдельные  
ветви алгоритма переплетаются, образуя запутанный клубок,  
в котором невозможно разобраться  

Решение проблемы получило название **объектно-ориентированноепрограммирование**   
или объектно-ориентированное проектирование или ООП.  
При использовании данного подхода, упорядочивание кода базируется  
на объединении данных, с одной стороны, и методов для обработки этих  
данных, с другой стороны, в одно целое. Это «одно целое» в ООП называется  
**экземпляром класса.**  
Вся программа при этом имеет блочную структуру, что существенно упрощает  
анализ кода и внесение в него изменения.  
ООП – искусственный прием, в большинстве случаев не зависящий, от языка  
программирования.  

**промежуточные итоги:**  
* Если говорят, что разработка идет с использованием ООП – это говорит о том, что используются классы и экземпляры этих классов.  
* Каждый **экземпляр класса** определяется общим шаблоном, который называется **классом**.  
* В рамках класса задается общая структура, на основе которой затем создаются экземпляры.  
* Данные, относящиеся к классу, называются полями класса (ничто иное, как переменные, объявленные в теле класса), а код для их обработки — методами класса.  

**Примеры:**  
Автомобиль – Lada 2107 UIN 123123123, S/N 789789789  
Здание – Дом по адресу г.Москва ул. Ленина 21к1  
Ученик – Сергей Камянецкий, 51 МиИ, СмолГУ  
Мобильный телефон – Siemens CX60 IMEI 1234520032022  
Геометрическая фигура – додекаэдр  
Работник – Смиронова Т.В. 14.02.1994, ID 728, Компания GeekBrains  
Котики – Барсик  

* **Чтобы вывести форматированную строку:**  
return String.format("id: %d, sl: %s, fn: %n, ln: %l" id, salary, firstName, lastName);  

* **Чтобы поменять базовое поведение стандартных функций** - необходимо переписать их в теле класса. Тогда для его экземплятров поведение данной функции будет таким, как определили его мы.  

* **Переопределить hashCode** по 1 параметру:  
public int hashCode() {  
        return id;  
    }  

* **Переопределить equals:**  
public boolean equals(Object obj) {  
        Worker t = (Worker) obj;  
        return id == t.id && firstName == t.firstName;  
    }  

public boolean equals(Object obj) {   
        if (obj instanceof Cat)  
            return ((Cat)object).name.equals(this.name)  
        else return false;  
    }  

* **Переопределить toString**:  
public String toString() {  
        return String.format("id: %d, sl: %s, fn: %n, ln: %l" id, salary, firstName, lastName);  
    }  

* **Вывести тип объекта (дочернего)**  
    public String getType(){  
        return super.getClass().getSimpleName();  
    }  



Модификаторы видимости(доступа) полей:  
* **public** - только в классе  
* **private** - во всей программе   
* **protecred** - в классе и у его наследников  
* **static** - переменная(поле) станет принадлежать только классу, но не его экземплярам. Это значит, что доступ к этой переменной будет по всей программе, даже не являющимся экземплярами классов. (**стараться избегать**, потому что под нее в любом случае выделяются ячейки оперативной памяти + считается нарушением инкапсуляции)

**Конструктор** - это метод без названия с таким же именем, как класс. Все, за что отвечает конструктор - построение экземпляра класса.  
* В теле класса может быть 2 и более конструкторов: пустой и заполненный(функциональный)  
  * пустой конструктор нужен для того, чтобы не прописывать каждый раз параметры, если эти параметры у экземпляров класса, по сути, одни и те же. Ниже пример.  
* Чтобы **создать конструктор автоматически**: alt + insert  
* super. - для вызова метода родительского класса  
* **экземпляр класса (объект) хранится в куче, ссылка на экзепляр класса (объект) хранится в стэке**.  
* минимальный конструктор: public Animal(){}; 


Пример **использования мин. конструктора** (когда параметры у всех экз. класса одинаковые). При этом произойдет неявная передача параметров в полнотелый конструктор из тела пустого конструктора:  
public Animal(){  
  this.legsCount = 4;     
  this.color = black;    
  this.type = Dog;  
};  

Можно создать **усеченный конструктор** (например здесь необх. передать цвет, ост. автоматически передастся в главный конструктор):  
public Animal(String color){  
  this.legsCount = 4;     
  this.color = color;    
  this.type = "Dog";  
}; 
public Animal(String color){  
  this(4, color, "Dog")  
}; 

* **Класс** - это шаблон для экземпляров класса.  

**Пример конструктора**:  
public class Animal {  
    int legsCount;  
    String color;  
    String type;  
public Animal(int legsCount, String color, String type) {  
        this.legsCount = legsCount;  // this - буквально - возьми входящее значение legsCount и присвой это значение этому параметру (объявленному в поле класса)  
        this.color = color;  
        this.type = type;  
    }  
}  



**ТОЛЬКО для private полей**!!:  
геттр и сеттр: (вызываются через alt + insert):  
гетр для получения инфы, сетр для переопределения значения  
Пример:  
Animal cat = new Animal("cat");  
int legsCount = dog.getLegsCount; // в этом случае получаем значение конструктора по умолчанию (4);  
cat.setLegsCount(3); // изменяем стандартное значение на 3.  

**Пример создания экземпляра с помощью конструктора**:  
Animal dog = new Animal(4, "black", "Dog");  

* **Привести объект к экземпляру класса**:  
((Cat) object)  

* **Проверить принадлженость объекта к классу**:  
if (object instanceof Cat) // Cat - класс  

Как пишутся классы:  
1. поля  
2. коснтрукторы
3. методы

* Чтобы создать/сделать класс наследником:  
public class Cat extends Animal{ //где Cat - дочерний, Animal - родительский   
} 

* Унаследовать конструктор от родителя:  
public Cat(String name, int legs, int eyes, String color){  
        super(name,legs,eyes, color);/ключевое слово super - для обращения к конструктору род. класса  
    }  

* //**статический инициализатор** - для инициализации статических полей  
    static{  
        count = 0;  
    }  
  * **static** - такой модификатор доступа, который позволяет напрямую обращаться к полю или методу. Без него пришлось бы создавать экземпляр класса и обращаться к его типу. Program.method(). При этом нет никакого текущего и нет никакого базового экземпляра. (this/super)  

* **abstract** - модификатор доступа к классу, который следует использовать, когда мы хотим **ограничить(запретить) создание экземпляров этого класса**. Это значит, что это класс необходим для дальнейшего наследования и только. При этом в нем, конечно, могут быть поля, конструкторы и методы. 
  * если использовать применительно к методам, то эти методы **должны** будут переопределены в наследуемом классе. Кстати неплохой способ, чтобы не забыть переопределить методы. Пример: BasicHero может умирать, соответственно все его наследники тоже. В базовом классе метод можно не описывать, но в дочерник описать мы обязаны.  

* для индексации или подсчета количества экземпляров класса:  
public Foo(){  
        count++;  
    }  

* **Скастовать, кастануть** - привести объект к другому типу объекта. 
((Druid)(druid))   
values = (T []) new Object[values.length + 1];  

* @Override - значит, что в классе переопределяется стандартный метод. 
  * для вызова методов для переопределения - ctrl + o  

**Интерфейс**  
interface предназначен для описания исключительно общего поведения сущностей.  
Частный случай: для гарантии, реализации некоторого поведения.  
Интерфейс – это частный случай класса.  
Он представляет собой полностью абстрактный класс с абстрактными членами.
У интерфейса по умолчанию все public! Менять не надо.  

*и так - если мы **имплементируем** интерфейс, то обязаны! переопределить методы, которые в нем находятся (как в абстрактном классе)  
public class Foo extends Hero implements Healer, Warrior{}  

*Абстрактный класс*  
Должен содержать 1 или более абстрактных методов.  

*Абстрактный метод* - метод без тела, и даже без фигурных скобок 

*Контракт* - условия, при которых чтобы пользоваться интерфейсом, необоходимо в обязательном порядке реализовать все его методы.  

* **Проверить объект на соответствие типа**:  
if (zooAnimals.get(i) instanceof Pets)  

* Чтобы **перезагрузить Идею**, когда видит ошибки в коде там, где их нет:  
File -> Invalidate Caches -> invalidate and restart  

> Вызывать методы в рамках текущего класса - через this, если нужно вызвать метод родительского класса - super:  
this.name (если метод описан в дочернем классе), super.name (если метод описан в родительском классе)   

Итератор<E>  
Итератор над «коллекцией». Iterator занимает место Enumeration’в Java Collections Framework.   
hasNext()  
next()  
Пример:   
Iterator<Integer> iterator = newList.iterator();  
        while (iterator.hasNext()){  
            System.out.println(iterator.next());  
        }   

**Важно!**  
Для итерации объекта: необходимо в классе имплементировать стантартный класс типа Iterator<String> or smth else  
public class Worker implements Iterator<String>...  
и **переопределить методы**:  
@Override  
    public boolean hasNext() {  
        return index++ < 4;  
    }  

    @Override  
    public String next() {  
        switch (index){  
            case 1:  
                return String.format("First name: %s", firstName);  
            case 2:  
                return String.format("Second name: %s", secondName);  
            case 3:  
                return String.format("Age: %s", age);  
            default:  
                return String.format("Salary: %s", salary);  
        }  
    }  
В **мейне напрямую объявляем**:  
Iterator<String> components = worker1; 

Чтобы **сравнить два объекта** (условно - **сравнить двух воркеров**):  
имплементируем Comparable<Worker>;  
реализуем метод toCompare: 
@Override  
    public int compareTo(Worker o) { 
      // 1 способ   
        if (o.age < this.age) return 0;  
        else if (o.age > this.age) return -1;  
        else return 1;  
      // 2 способ  
      return Integer.compare(o.age, this.age);  
    }  

Iterator<Component> - обязательная реализации итератора. Вариант исполнения - анонимный класс. Создавать в том классе, который хочу итерировать.  
Пример:  
int index = 0;  
@Override  
    public Iterator<Component> iterator() {  

        return new Iterator<Component>() {  
            @Override  
            public boolean hasNext() {  
                return index < components.size();  
            }  
            @Override  
            public Component next() {  
                return components.get(index++);  
            }  
        };  
    }  

* Как создать список с разными типами объектов:  
**создать интерфейс "Маркер"**, имплементировать его всем объектам, которые хотим добавить в список. И создать список с типом "Маркер"  



**Ассоциация. Аггрегация и композиция.** 
Ассоциация - когда два объекта как-то связаны между собой. (когда один класс содержит поле с типом другого класса)  
Аггрегация - частный случай ассоциации, когда в нем есть конструктор, принимающий поле другого класса.  
Композиция - частный случай ассоциации, когда в конструкторе используется создание типа другого класса. Оба экземпляра класса не могут существовать по отдельности (это жесткая сцепка)  

* Сериализация — это процесс сохранения состояния объекта в последовательность байт.  
Десериализация — это процесс восстановления объекта из этих байт.  
Serializable (**сериалайзбл**) - означает, что класс может быть переведен в бинарный код, и десиарайзбл - обратно. (ХЗ как использовать)  
implements **Serializable - интерфейс-маркер.** Он просто помечает машине, что эти данные разрешено переводить в бинарные код.  

**Пользователь** - в 80% случаев в комьюнити, подразумевается другой программист.  

* **Анонимный класс** - это экземпляр стандартного интерфейса без имени, в теле которого описано какое-то поведение.  


Создать "**Сырую строку**" 
List list = new LinkedList(); // пример сырой строки. такая строка может содержать как числа, так и 
// строки и т.п. 


---
**Обобщение**(Generic/дженерик) <E>/<T>, где E - entity, T - type (просто сокращения, по сути ничего не значат) (Параметрический полиморфизм) - продумывание иерархии без привязки к каким-то конкретным типам 
Дженерики - это функция времени компляции. Что это значит? - то есть параметр типа стирается, а все дженерики реализуются как тип Object   
// класс с обобщенным типом. при объявлении экземпляра класса произойдет конкретизация типа параметра id, за исключением **случая <?>** - (wildcard/вайлдкард) когда мы объявляем коллекцию, но все еще не знаем какой тип в ней будет лежать. (имеет смысл при создании абстрактного класса.  его экземпляры могут возвращать разные мапы с разными типами.) В абстрактном классе Map <?, ?>, а в экземплярах уже конкретизируем...   
Пример: 
public class Multiparameterized <E1, E2, E3>{  
    public E1 value1;  
    public E2 value2;  
    public E3 value3;  

    public Multiparameterized(E1 value1, E2 value2, E3 value3) {  
        this.value1 = value1;  
        this.value2 = value2;  
        this.value3 = value3;  
    }  
}  

* **Чтобы решить проблему того, что в обобщенный класс можно положить теперь абсолютно любой тип**:  
делаем наследование обобщенного метода от какого-то верхнего класс всех будующих типов  

public class Repository <T extends Numbers> {  //при этом T может быть int, double, float, long etc...   
}  

//**метод для возвращения неизвестного на текущий момент типа**
public class Methods {
    public static <U> U getElement(List<U> col, int index){
        return col.get(index);
    }
}

* Ограничить wild сверху:  
<? super T/Cat>, тогда сюда войдет Cat и все родители...  
---

Класс **Enum** - для создания некоторого ограниченного круга значений.. Например, цвет:  
public enum Color {  
    black, white  
}  
Cat cat = new Cat(9, **Color.black**, "Barsik"); // чтобы вызвать такое значение  

* Чтобы присвоить значению значение нового массива:  
this.values = (T []) new Object[0];  


* **Тесты**:  
создаются - по названию класса, который тестируем + Test. GBArrayListTest. Тоже самое с методами.  
Каждый тест должен быть изолирован. То есть внутри метода с тестом создаем экземпляр класса, и для этого экземпляра тестируем отдельный метод.  
**Чтобы добавить библиотеку для тестов** : @Test - и выбрать первое решение  
Пример:  
@Test  
    void getTest(){  
        GBArrayList<String> testList = new GBArrayList<>();  
        testList.add("1");  
        Assertions.assertEquals("1", testList.get(0));  
    } 

@Test  
    void getNegativeTest(){  
        GBArrayList<String> testList = new GBArrayList<>();  
        testList.add("1");  
        assertNotEquals("2", testList.get(0));  
    }  

@Transient - значит, что это переменная не будет сохранена в объектном файле при компилляции. (значение этой переменной будет равно нулю)  


---
**Полезные ссылки:**  
1. канал для изучения JAVA - https://www.youtube.com/channel/UCK5d3n3kfkzlArMccS0TTXA
2. статья о LinkedList - https://habr.com/ru/articles/337558/  
