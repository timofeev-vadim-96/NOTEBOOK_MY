# LINUX

пароль Ubuntu/root = lokation

Преподаватель GB (Лекции) - Николай Лавлинский    
Преподаватель GB (Семинары) - Сергей Акопян (Яндекс Толока, Яндекс Алиса)

GNU/Linux - объективно, есть смысл использовать только в качестве серверной операционной системы  

Зачем вообще нужен Linux? - из-за тотального доминирования в серверном сегменте:  
● 100% TOP-500 суперкомпьютеров
● 95% самых популярных сайтов
● 90% облачной инфраструктуры
● Стандарт де-факто для
веб-приложений

Assembler - низкроуровневый машинный код  

`Системные вызовы в Linux:`      

● Управление процессами:
○ fork() – создание нового процесса клонированием
○ exec() – запуск программы
○ exit() – завершение программы

● Управление файлами:
○ open() – открыть файл //не имеет значение место хранения файла и его структура  
○ read() – прочитать данные из файла
○ write() – записать данные в файл
○ close() – закрыть файл

`Серверные и настольные системы:` //имеют общее ядро (основа OC) в Linux     

**Серверные (server) ОС**  //у пользователей нет доступа к серверам, за исключением администраторов  
● Платформа для сервисов (веб-сервер,
база данных…).
● Может не иметь графического
интерфейса.
● Имеют высокую стабильность.
● Работает 24/7  

**Настольные (desktop) ОС**  
● Платформа для приложений.
● Имеет графический интерфейс.
● Имеют высокую совместимость с
пользовательским ПО.

UNIX-подобные системы - начиная с 1970г. - движение открытого ПО (хотя изначально создавалось как коммерческий продукт)

Существует несколько диструбутивов Linux:  
1. (Debian (DEB) (DEB - формат упаковки пакетов)) (Debizn - название компании) - `Ubuntu`    
2. (Red hat (RPM)) - `Oracle Linux` 
3. Red hat - `CentOS` 
...

`Ubuntu`:  
1. Server  
1.1 LTS (выходят каждые 2 года) - long term support - гарантированная поддержка системы в течении 5 лет и более, обновление безопасности и свежих версий ПО     
1.2 no LTS (выходят каждые 6 мес) - поддержка порядка 9 мес. 
2. Desktop
2.1 LTS  
2.2 no LTS  

* Чтобы установить Linux OS поверх своей:  
Виртуализация в VirtualBox, например OracleVirtualBox  
● Межплатформенный продукт.
● Требуется поддержка аппаратной виртуализации в CPU.
● Широкие возможности по экспериментам
p.s. Для Mac M1,M2... (M)  не сработает  

Требования к железу для работы/установки VirtualBox:  
● RAM от 2048 MB
● Диск от 20 GB
● Загрузка с установочного ISO //образ оптического диска  

Для MacOS:  
1. https://mac.getutm.app/  - виртуальная машина  
1.1 Или вирт машина Parallels  
2. https://romankurnovskii.com/ru/posts/howto-install-ubuntu-desktop-on-arm/ алгоритм  

- **Для начала работы** необходимо скачать одну из виртуальных машин, затем скачать iso образ одного из дистребьютеров Linus, например, Ubuntu, и создать виртуальную машину с образом Linux.  
---

`Commands/Команды:`  
* sudo systemctl status - диагностика проблем 
* sudo //запуск от имени администратора 
  * sudo su //чтобы войти в качестве рута
  * чтобы выйти из админа - exit 
* visudo - редактирование
  * редактирование начинается в файле .temp, после чего программа проверит синтаксис и предложит его изменить, если что-то не так
  * % означает группу
  * решетка - комментарий
  * %sudo ALL=(ALL:ALL) ALL - полные права на все команды и директории
    * %sudo ALL=(ALL:ALL) NOPASSWD:ALL - не будет требовать пароль для команд sudo
    * ALL=(ALL:ALL) /user/bin/passwd - доступ на изменение только одного файла 
* su - переключение пользователей
  * su newUser
  * exit - чтобы выйти в своего пользователя (рута)
* sudo apt update //проверяет наличие актуальных версий приложений в пакетном менеджере на сервере  
  * sudo apt upgrade //устанавливает все эти обновления
* sudo apt install gcc make perl - перед началом работы в новой операционке (в виртуал боксе) //это название трех необходимых пакетов для дальнейшей работы (**гостевые пакеты**)
  * доп: sudo apt install tree  
* sudo apt install terminator - крутой терминал (консоль)
  * переключение между окнами - Alt+стрелка (влево-вправо и т.д.)
* sudo apt install openssh-server //установка SSH-server 
* `sudo ./VBoxLinuxAdditions.run` // настройка модулей ядра операционной системы дляработы с Линукс Убунту, оптимизации декстом графики. Запускать, находясь в папке. Можно перейти через cd /media/vadim/... (перед этим подключить образ диска не забудь)
  * Для этого необходимо смонтировать диск (iso): устройства -> подключить образ диска...
* sudo reboot //перезагрузка операционной системы
* ip a //мой ip
* ip route - сетевой маршрут
* watch -n 0.5 - выполняет следующую команду, которую написали с интервалом (-n) в 0,5 сек
  * watch -n 0.5 ip a //показывать ip и обновлять каждые 0.5 сек данные 
* mc // запуск миднайт коммандера  
* добавить пользователя в качестве администратора:  
  1. su
  2. usermod -a -G wheel имя_пользователя  
* ps - показывает все текущие запущенные процессы
  * -a - все процессы, кроме фоновых
  * -f - вывести макс. доступных данных, количество потоков
  * ps -afx - таблица процессов
  * ps -aux - все запущенные процессы в системе
  * ps -eH - процессы в виде дерева (отступами)
  * pstree - - процессы в виде дерева линиями
* sort - сортировка по алфавиту
* df - показывает все файловые системы (диски), свободное и занятое на них пространство
  * -h - размер будет читаем (в килобайтах)
* bash - запустить еще один вложенный процесс
* -e file - проверка наличия file - возвращает true/false
* let - для арифметических действий с пользовательскими переменными
  * let "c = c - 1"
* type - узнать тип команды (команда под капотом или запускаемый фал (покажет путь))
  * type ls
* read - считать с консоли значение
  * read a // и присвоить значение в переменную а
* basename /home/vadim/temp/vadim - вернуть просто имя файла или папки
* chroot - изменение корневого каталога системы (все что находится ниже нового рута - изолировано от остальной файловой системы)
* ldd /bin/bash - отобразит все зависимости для исполняемого файла /bin/bash
* top - список текущих процессов в реальном времени
* htop - список текущих процессов `подсвеченный`
  * нужно доустанавливать apt install htop
* uname - инфа о системе
  * uname -a - вся инфа о системе
  * uname -r - инфа о ядре
  * uname -m - разрядность системы (х86)
  * uname -n - инфа о вирт. машине/имя хоста

* ls - показать содержимое текущей дерриктории  
* which ls - покажет в какой папке лежит исполняемый файл команды ls 
* source .filename - обновить файл
* sudo passwd root - `установить пароль к доступу к акк админа`
* для того, чтобы добавить alias/алиасы (макросы/псевдонимы) - 91 строка .bashrc (файл в корневой папке)
* echo "hello" //эхо, выведится тоже самое
  * -n - не добавлять перенос строки
  * -e - для цветов (нужно еще дописать блок кода, определяющий сам цвет)
  * можно дозаписать куда-то: echo "Hello2" >> file/ перезаписать: echo "Hello" > file
* id - показывает айдишники и группы с их айди, в которые мы входим
* whoami - покажет текущего пользователя
* ls -l /proc/$$/ns - вывести все действующие пространства имен
  * lsns - вообще все пространства имен

`Commands for working with files`  //команды для работы с файлами

* ls - выводит содержимое текущей дерриктории
  * ls /etc/apt - если к конкретной папке
  * ls -l - вывод с толбик
  * ls -a - все файлы, в т.ч. скрытые
    * ls -la - в столбик
  * ls -A - тоже самое, но без текущего и родительского (точки)
    * ls -lA - в столбик
    * ls -lAh - тоже самое + вес отображается в К
    * ls -lAhi - тоже самое + i-nodes
* pwd - путь от корня до текущей дериктории
  * ./ - тоже текущая дериктория
* cd - для перемещения (без модификаторов - в домашнюю деррикторию)
  * пример: cd /etc/apt/
  * cd - //вернуться в папку, где мы были
* mkdir - создание дирректории
  * mkdir -p 1/2/3/4/5 - создать каскад директорий. -p - parent
* cp - копирование
  * cp -r dir1/* dir2
* rm -  **ОПАСНАЯ КОМАНДА**  
  * для удаления каталогов: rm -r dir1 //-r значит рекурсивно
  * rm -f file // -f - force - для удаления без подтверждения (для других систем, в Ubuntu - итак без подтверждения) 
  * rm -r *.tmp - удаление с маской  
* mv - перемещение/переименование //перемещает 1 и более аргумент в последний аргумент. !!!Последний аргумент должен быть каталогом!!!
  * Пример для переименования: mv file1 file3
  * если при перемещении файл с таким именем уже существует в конечной дирректории, то он его заменит.
  * чтобы переместить все содержимое папки: mv dir1/*
* touch - изменяет время последнего доступа/изменения файла (по-простому: когда этот файл последний раз трогали)
  * если указать не существующий файл - создасться новый. Пример: touch file1
* touch ~/file1 // создать файл в домашней дирректории
* cat - вывести информацию, содержащуюся в файле: cat file1
  * перенаправить содержимое: cat file1 > file2, где > это перезаписать, а >> дозаписать
    * можно перенаправить с двух файлов (конечного файла может не быть): cat file1 file2 > file3
  * наполнить файл содержимым (если файл не существует, он создасться): cat > new_file; набираем текст; Ctrl + D
* tree - показать дерево с папками и файлами в текущей дерриктории
  * tree -L 1 // Уровень вложенности 1,2,3...
* stat - для получения инфы о файле
  * stat -c "%U" file - информация по формату (-c) макси (%U) - пользователь-владелец


`Ссылки:`
* ln file hlink - жесткая ссылка //ссылается по inode, на конкретное место в памяти. Даже при удалении исходного файла
p.s. Используются в системах резервного копирования (бэкапы)  
p.s.2 Нельзя использовать на каталоги (но сущ. в ОС - . и ..)
p.s.3 работает только в рамках одной файловой системы  
* ln -s file slink - мягкая ссылка//ссылается по пути (при переименовании исходного файла, потеряет его) //по факту как ярлык в винде
p.s. Можем ссылаться на другие файловые системы
p.s.2 По сути - файл, в котором прописан путь. Так что имеет свой вес, имеет отдельный inode  
p.s.3 Лучше указывать полный путь, тогда можно перемещать по файловой системе  
p.s.4 Можно использовать на каталоги  

**Дальнейшая настройка** (Начало работы):   
1. Устройства - общий буфер обмена - двунаправленный  // для того, чтобы можно было копировать текст и переносить из одной ОС в другую.  
2. Устройства - общие папки - настройка общих папок. Добавляем папку Загрузки из основной операционной системы для возможности импорта файлов. 
Точка подключения - папка в виртуальной машине (в Ubuntu). Например: /home/vadim/windows_dir, где home - папка с домашними директорями всех пользователей, vadim - текущий пользователь. Поставить галку - создать постоянную папку
3. Устройства - сеть - настроить сеть - Сетевой мост - для корректного отображения ip (новый - для нашей виртуальной машины, даже ролтер будет видеть как второе устройство) // по новому ip можно подключиться к серверу через ssh   
  * Чтобы подключиться к серверу Ubuntu из Windows:  
  ssh vboxuser@192.168.0.10 // где vboxuser - имя польз., после собаки - ip Unbuntu  
  * Чтобы отключиться в cmd(windows): exit/Ctrl+D 

* Сетевые режимы VitrualBox:  
● Мост (bridge) – ВМ в локальной сети, прямой доступ к ВМ по IP.  
● NAT – ВМ в своей сети, доступ к машине только через проброс портов.  


**Устанавливаем Миднайткомандер (midnight commander)** - Один из файловых менеджеров с текстовым интерфейсом: 
sudo apt install mc  
  * После установки - параметры -> убрать галку "Включить быструю клавишу доступа к меню", это для выхода через F10

**чтобы открыть терминал**: Ctrl + Alt + t

**проскролить до пустого экрана**: Ctrl + L  

**копирование и вставка**: Ctrl+Shaft+C и аналог.  

**Чтобы открыть справку по любой утилите, например apt**:  
sudo apt --help  / man apt - откроет мануал

**Сменить язык в терминале** - https://firstvds.ru/technology/kak-nastroit-podderzhku-russkogo-yazyka-v-terminale-linux  

---

## Оболочка (Bash) 

- слой(интерпретатор) для связи с ОС

**Приглашение оболочки**: db@linus-host:`$, где db - user, linux-host - comp. name/host name, wave - current catalog, $ - userTipe  

---

## Пользователи

**Типы пользователей:**  

.# - root (админ) 
  * UID (user id) = 0
  * не ограниченные права
  * Home /root
  * пароль не всегда 
  * есть shell - наша оболочка (bash)
.$ - user (обычный) 
  * UID по молчанию >=1000   
  * Home /home/user
  * Пароль установлен
  * Есть shell
  * Доступ в рамках домашней директории
- daemon (системный пользователь) //работает в фоновом режиме и управляет какими-то процессами
  * 1 < UID < 1000
  * Home любая
  * Пароля нет
  * Нет shell
  * Права максимально ограничены  

**Атрибуты пользователей**  

● UID – user ID //1000  
● GID – group ID //1000  
● Домашняя директория (home) // /home/{user}  
● Логин (login) // {user}  
● Пароль (password)  
● Оболочка (shell) // /bin/bash  

**Хранение данных пользователей:**  // не рекомендуется редактировать файлы вручную!!!  
● /etc/passwd – список пользователей  
  * root:x:0:0:root:/root:/bin/bash, где root - админ, х - раньше был пароль (теперь вынесет в shadow), 0 - UID, 0 - GUID, root - полное имя пользователя, /root - домашняя директория, /bin/bash - оболочка   
● /etc/group – группы пользователей  
  * vadim:x:1000:, где vadim - название группы, x - пароль группы(заглушка), 0 - GUID, после : список пользователей, которые туда входят (если эта группа для него дополнительная. Если основная - она указана в passwd в индексе)
● /etc/shadow – пароли пользователей  
  * root:!:19545:0:99999:7:::, где root - login, ! - пароль (шифруется через hash-функции, не хранится в чистом виде) или блокировка (отсутствие пароля), после : свойства пароля (время установки, время действия пароля (если 99999 - бесконечное действие))

**Управление пользователями**  
//все команды с пользователями через админку  
● useradd – создание пользователя  
  * sudo useradd -s /bin/bash -m -d /home/newUser newUser //-s - оболочка, -m - создать дом. директорию, -d - путь к домашней директории, newUser - login
● adduser – создание пользователя (скрипт) //упрощает создание пользователя, требует меньше параметров. По минимуму - достаточно имени пользователя
  * sudo adduser testuser2 (--force-badname)*предложат в подсказках  
● usermod – изменение пользователя  
  * sudo usermod -aG adm newUser //добавить пользователя в группу. -a - add, G - group (доп. группа)/g - основная группа, adm - существующая группа
  * Изменения вступят в силу после того, как пользователь перезайдет
● userdel – удаление пользователя  
  * sudo userdel testUser2, при этом, его домашняя директория останется. Так что не забыть удалить и ее. 
    * sudo rm -r /home/testUser2
● passwd – изменение пароля  //для себя
  * sudo passwd newUser //для другого пользователя
● chage – изменение свойств пароля //используется для ограничия времени для временного сотрудника
  * sudo chage newUser 
● groupadd – создание группы 
  * sudo groupadd testgroup 
● groupdel – удаление группы  
  * sudo groupdel testgroup
● gpasswd - удаление пользователя из группы
  * sudo gpasswd -d vadim testgroup2
* groups - в какие группы входит пользователь
  * groups testuser
* создать пользователя с правами на команды sudo:  
  * sudo usermod -aG sudo testuser


**Изменение владельца и группы владельцев файлов**  
● chown – (change owner) изменение владельца и группы  
○ chown -R – рекурсивно  //изменить владельца для каталога и всех вложенных эл-ов **ОПАСНАЯ КОМАНДА**
  * sudo chown -R newUser:adm /home/newuser/testdir
○ chown testuser:testgroup  //определить и владельца, и группу
○ chown testuser  //определить только владельца
● chgrp – (change group) изменение группы
  * sudo chgrp -R www-data /home/newuser/testdir
○ chgrp -R –рекурсивно
○ chgrp testgroup

### Права доступа

- используются для разрешения взаимодействия компонентов, запуска приложений, широкого круга задач по безопасности и т.д.

**Пример**:  
-rwxr-xr-- (биты доступа), где -rwx (1-3 бит) - права для владельца, r-x (4-6 бит) - права для группы, r-- - права для остальных 
- прочерк, не установлен;  
- r - read - права для чтения/показать список документов (для директории);
- w - write - для изменения файла/создание новых элементов (для директории);
- x - exicute - исполнение файла/зайти в директорию;

`Права доступа для ссылок определяет файл, на который она ссылается!`

Специальные биты:
1. SUID (s) - 4000 (8-ричная форма) для владельца - s - запустит файл от имени владельца этого файла. Используется для запуска программы от рута
  * S - файл не исполняемый (x - не активен, S поверх икса)
2. SQID (s) - 2000 для группы владельцев, для доступа от имени группыю. 
3. Sticky bit (t) - 1000 - для остальных. (приклеивается только на папку). Удаление файла только для владельца директории или рута, разумеется. Пример: папка /tmp. При этом программы из этой папки могут удалить только те файлы, которые они создали до этого, с помощью rm -r /tmp
Пример: -rwsr-sr-t

**Изменение прав доступа**
● chmod — change mode, изменение прав доступа **ОПАСНАЯ КОМАНДА**
○ chmod -R a+w testdir/ – рекурсивно
○ chmod u=rwx,g=rx,o=r testfile – символьная форма  
  * sudo chmod u=rwx,g=rw,o=rx newFile
○ chmod 751 testfile – числовая форма (восьмиричная), где 7 - для владельца, 5 - для группы, 1 - остальные
  * sudo chmod 664 newFile, где 664 - стандартные права "по умолчанию": -rw-rw-r--
○ chmod a+x – изменение для всех
  * sudo chmod +r new_dir/
  * можем использовать = - уст. точные права, + добавить права, - убрать права
  * sudo chmod g+s new_dir/
○ chmod 4755 – изменение специальных битов, где 4 - спецбиты, 755 - осн. биты

**через mc** - CTRL + X, C - для назначения прав доступа - справа (в восьмиричной форме, как в спец.битах 4 посл. цифры)

**Права по умолчанию и umask**
Права для файла/директории
* полные права 666/777
* значение umask 022/022 - понижение полных прав до прав по умолчанию
  * umask - для проверки значения на данный момент в консоли (0002 - по умолчанию)
  * umask 022 - установка
* права по умолчанию 644/755

---

Структура папок в Ubuntu:  
* bin - бинарные файлы, утилиты  - **все команды (типо ls, pwd  и т.д.)**
  * usr/bin - бинарный файлы, предн. для user
* boot - информация для загрузки системы (загрузчик grab (для выбора ОС))
* dev - девайсы, все устройства, сервера и виртуальные машины
  * файл sda - главный жесткий диск (sda1, sda2 - разделы)
* etc - папка для общих конфигов (apt, ssh, ...) //тут хранятся пакеты
  * /etc/skel - (skeleton) файлы для создания новых пользователей
  * ssh_config - конфиги для доступа куда-то
  * sshd_config - конфиги для доступа к нашему серверу
  * /etc/sudoers - конфигурация sudo
* home - домашние дирректории пользователей
  * ~/ - тоже самое
  * bashrc - конфиги для оболочки (выделение текста, псевдонимы команд и т.д.) - вместо него может быть ssh (более новый вариант)
* media - для автоматического монтирования с помощью проводника
* mnt - для ручного монтирования
* lib 32/64 - с разл. библиотеками для приложений
* opt - файлы разл. приложений, которые мы ставили не через пакетный менеджер 
* proc - данные запущенных на данный момент процессов в опер. памяти
  * /proc/cpuinfo — инфа о процессоре, можно посмотреть через cat 
  * /proc/version — версия ОС
* root - домашняя дирректория суперпользователя
* run - дирректория, в кот. хранится инфа для запуска приложений
* sbin - бинарники, требующие разрешения суперпользователя для запуска
* snap - файлы пакетного менеджера snap
* srv - ?
* sys - информация о системе
* tmp - временные файлы
* user - слепок папок для одного юзера
* var (variable) - изменяемые файлы, базы данных и т.д.
  * log - логи
    * var/log/syslog - логи системы
* swapfile - файл подкачки - предназначен для хранения файлов, которые не поместились в оперативную память

`скрытый файл` - долджен начинаться с точки  

`Относительные и абсолютные пути:`  
● Абсолютные:  
○ начинаются с корня /  
○ всегда указывают на один и тот же объект  
○ cat /var/log/syslog  
● Относительные:  
○ не начинаются c /  
○ зависят от текущего положения  
○ cat test/testfile  
---

---

`Текстовые редакторы:`  
1. vim. Для обучения - vimtutor прямо в коноль
Имеет 3 режима работы:  
* Командный режим (Esc)
  * навигация по файлам
  * копирование и вставка
  * удаление символов и строк
  * поиск текста 
* Режим редактирования (I/insert)
  * ввод и редактирование текста (как в обычных редакторах)
* Режим последней строки (: (двоеточие))
  * сохранение файла (w)
  * выход из редактора (q), без сохранения (q!)
  * изменение настроек(set)
    * запись и выход (wq)
2. nano
  * .nanorc - тип файла для работы
  * set linenumbers - нумерация строк
  * set softwrap - перенос построчный 

^ - Ctrl  
M - Alt  

Обозн. горячих клавиш:  
● Cправка — Ctrl+G  
● Сохранение файла — Ctrl+O  
● Выход — Ctrl+X  
● Включение номеров строк (нумерация строк) — Alt+N  
● Поиск — Ctrl+W  

3. mcedit //не популярный

`Терминальные пейджеры:`  
head: head -n 3 .profile //вывести первые 3 строчки файла
tail: tail -n 3 .profile //вывести последние 3 строчки файла
more: more .profile // разворачивает содержимое файла, как свиток. При этом весь текст останется в терминале и засоряет его
less: less .profile //не засоряет терминал после выхода (чтобы выйти - q)
  * home - к началу
  * end - к концу
  * page up/down - перемещение полистно
  * стрелки - перемещение построчно

`Типы файлов:`  обозначение для команды ls и midnight commender (первая буква при выводе содержимого директории)
1. обычный: -/нет
2. директория: d/slash(l)
3. блочное устройство (внешнее устройство с мин.обращением(например, 512Б)): b/+
4. символьное устройство(устройство, взаимодействие с которым происходит по-символьно(мин. 1 символ)): c/-
5. UNIX-сокет (файл с правами доступа, через который происходит взаимодействие пользоваетелей в сети): s/=
6. Именованый канал(файл для взаимодействия различных программных утилит между собой): p/|
7. Символическая ссылка: l/@ и ~

* inode - индексный дискриптор - структура данных, в которой описаны методанные о нашей системе (вся инфа о файле, кроме самих данных и имени файла). Какие методанные: права, вес, дата изменения, пользователь, группа пользователей


`Скрипты` - любой скрипт - это текстовый файл. Может не иметь расширения.
«sсript» — это сценарий. На практике это набор команд, в которых прописана какая-то последовательность действий.
Bash - язык программирования
  * Шпаргалка(шпора) по баш: [https://devhints.io/bash] (Шпаргалка по Bash)  
Исп. файл /bin/bash - свое рода интерпретатор

**Код возврата (завершения)** - exit code //код ошибки - возвращает число от 0 до 255. Если 0, то ошибки нет 
● Код ошибки последней команды
● Проверить: echo $? // посмотреть код возврата. $ - обращение. ? - это спец. переменная
● Условная связка (И): ls -al && echo "Success!" //выполнить обе команды в случае успеха
● Условная связка (ИЛИ): ls -al || echo "Fail!" //выплнить эхо феил в случае провала

`Потоки ввода-вывода`
* STDIN (0) ввод
* STDOUT (1) вывод
* STDERR (2) ошибки //и логирование

`Перенаправление потоков ввода-вывода`
● program < file – перенаправление ввода из файла file
● program > file – перенаправление вывода (STDOUT) в файл file (запись с начала файла) //если file не существовал, то он будет создан, при наличии прав на создание в конкретной директории
● program >> file – перенаправление вывода (STDOUT) в файл file в режиме дополнения файла
● program 2> file – перенаправление ошибок (STDERR) в файл file (запись с начала файла)
  * program 2> /dev/null - перенаправление в бездну
● program 2>> file – перенаправление ошибок (STDERR) в файл file в режиме дополнения файла
● program > file 2>&1 – перенаправление вывода (STDOUT) и ошибок (STDERR) в файл file //если дозапись, то изменить первую угл.скобку
(запись с начала файла)

`Конвейер (pipeline, pipe)`  //данные перенаправляются. Работает только с утилитами, работающими с STDIN потоком
● Перенаправление ввода-вывода между процессами
● ls -al | grep file //фильтрация по слову file
● ls -al | grep -P '\.[cs]+'
● `подсчет строк:` cat /var/log/syslog | grep 'mysql' | grep -v 'file' | wc -l  //поток сислогов фильтруем по слову mysql -> строки, которые не входят в предыдущий поток -> фильтруем по слову файл -> wc - считает количество слов (-l модификатор заставляет считать количество строк)
  * wc - по умолчанию выводит 1: количество строк. 2. количество слов. 3. количество байт

* grep - «search globally for lines matching the regular expression, and print them» - «искать везде строки, соответствующие регулярному выражению, и выводить их».
  * cat /proc/cpuinfo | grep CPU
  * -P - регулярные выражения языка Perl  
  * -n - выводит еще и номера строк
  * -C 1 - вывод контекста (строка выше, строка ниже, если 1. если 2 - соответственно по 2)
  * -v - вывести все, за исключением шаблона
    * grep -v error
  * -i - без учета регистра
  * grep '^\.' - ищем все скрытые элементы. Крышка - это начало строки, слэш - экранируем точку.

  `Bash-скрипты`
* script.sh - расширения баша (не обязательно указывать расширение)  
**Переменные** //нельзя начинать с цифры, без пробела, без спец. символов
● Переменные окружения //пишутся в верхнем регистре
  ○ $PATH
  ○ $UID
  ○ $PWD
    * echo $OLDPWD - выведет предыдущую деррикторию
● Пользовательские переменные //видны только в текущей сессии. Сделать видимость в др. сессиях возможно с помощью  команды "export"
  ○ var1=test //без пробелов
    * var2='rat ata tat' //если значение с пробелом - то исп. одинарные ковычки
    * var3="$var2" //интерполяция - запишит именно значение переменной var2 в себя
  ○ echo $var1 - чтобы вывести значение переменной var1
  ○ var3=$(la -al) //результат команды записать в переменную
    * var3=`la -al` //абсолютно тоже самое (более старая версия записи с бэк-тиками)
● Специальные переменные
  ○ $1…$9 //аргументы, передаваемые скрипту  
    * $# - количество переменных
    * $@ - все аргументы в виде разделенных String  
  ○ $?

* printenv - чтобы вывести все переменные нашего окружения

`Пример скрипта Bash`
cat > testscript  
#!/bin/bash // так называемый шебанг. Определяет, на каком языке написан скрипт и какой интерпретатор будет применен. Обязательно идет первой строке в скрипте и без пробелов сначала (здесь - первая строка в файле testscript) 
directory=$1  
hidden_count=$(ls -A $directory | grep '^\.' | wc -l) //в значение переменной подставляется результат выполнения команды в кобках  
echo "Hidden files in $directory found: $hidden_count"  

`Методы запуска скрипта`
● Относительный путь: ./testscript
● Абсолютный путь: /home/db/test/testscript //для планировщика могут понадобится права на исполнение
● Команда (должен быть в $PATH): testscript
● Через команду bash: bash testscript //в баше права на исполнение есть у всех категорий пользователей
● Первые три варианта требуют шебанг и права на исполнение //необходимо выставить бит на исполнение

`Циклы и ветвления языка bash`
Синтаксис:
if [[ выражение ]]; //обязательно наличие пробелов вокруг квадратных скобок
 then
 Действия, если выражение истинно
 else
 Действия в противоположном случае
fi
Пример:
if [[ -e file_name ]];
 then
 echo "true"
 else
 echo "false"
fi

`Варианты условий`
**Операции сравнения строк**  //man test - мануал по условиям
● = или == возвращает true (истина), если строки равны
● != возвращает true (истина), если строки не равны
● -z возвращает true (истина), если строка пуста
● -n возвращает true (истина), если строка не пуста
**Операции проверки файлов**  
● -e возвращает true (истина), если файл существует (exists)
● -d возвращает true (истина), если каталог существует (directory)
Операции сравнения целых чисел (наиболее используемые) //сравнение чисел смотри в man test  
● -eq возвращает true (истина), если числа равны (equals)
● -ne возвращает true (истина), если числа не равны (not equal)

`Цикл for`
Синтаксис:
for имя_переменной in значения;
do
 тело_цикла
done
Примеры:
for h in {01..24};
do
echo $h
done
for (( c=1; c<=5; c++ ));
do
 echo "Попытка номер $c"
done
for i in /etc/rc/*; do //перебрать все файлы
  echo "$i"
done

`Цикл while`
Синтаксис:
while условие;
do
 Тело_цикла
done
Пример:
c=10
while  $c -ge 0;
do
echo "Test"
let "c = c - 1"
done

`Варианты установки софта в Linux`
* Исходный код
* Скомпилированные файлы
  * // могут быть проблемы с безопасностью 
* Пакеты - небольшой архив, содержащий в себе скомпилированные файлы + метаинформация (зависимость от пакетов и утилит, библиотек, доп. софта, подтягиваемая автоматически)
  * deb (debian - for Linux, основные пакеты, имеют зависимости, для их докачки), rbm, snap (дополнительные пакеты, более тяжелые, т.к. содержат все зависимости внутри своих пакетов) - это типы пакетов
    * 2 пакетных менеджера для deb:  
    1. apt - автоматизировання и лояльная к пользователю
    2. dpkg - более низкоуровневая утилита

`Классификация репозиториев (для deb Ubuntu)`
По разработчику: (условно по уровню доверия)
● Стандартные //гарантия совместимости и работоспособности
● Дополнительные 
● Неофициальные //могут работать (но это не точно)
По лицензированию: 
● main – открытое с поддержкой (открытый исходный код)
● restricted – проприетарное с поддержкой (закрытый исходный код)
● universe – открытое без поддержки
● multiverse – проприетарное без поддержки
По версиям ПО:
● $release (версия на момент выпуска ПО)
● $release-security (обновление безопасности)
● $release-updates (обновления, связанные с функциональностью, обновление софта)
● $release-backports (обновы для Betta-тестирования. Что-то более свежее, чем то, что есть в дистрибутивах)

`Подключение дополнительного репозитория` //в случае, если в стандартном дистрибутиве отсутствуют интересующие нас версии софта, и нужно его обновить файл
● /etc/apt/sources.list – добавление репозитория в основной файл//файл с конфигурацией репозиториев (сюда можно дописать ссылки на новые репозитории)
● /etc/apt/sources.list.d/*.list – добавление файла с адресом  //в директорию ...d можно добавить файлы с расширением .list (файл, в котором прописан новый репозиторий)
● deb http://адрес_репозитория версия_дистрибутива ветка // это формат записи о репозитории. Deb + адрес + верия + ветка/раздел (версия и ветка находится на сайте разработчика софта), адрес репозитория нужно найти на сайте разработчика ПО. Не забыть поменять <mydist> на наш дистрибутив, например - jammy (без скобок). А еще не забыть скачать ключ и установить его. Позже софт можно будет обновить с помощью apt upgrade...
● deb http://nginx.org/packages/ubuntu jammy nginx //пример
● sudo apt-key add repo.key – добавление ключа репозитория (по ключу происходит проверка на доверенность репозитория)

`Поиск пакетов и репозиториев`
**Основные (дистрибутив)**  
● Не требуется усилий
● Гарантированная работа
● Совместимость
● Не всегда свежие версии
**Разработчик ПО**  
● Требуется поддержка
дистрибутива и версии
● Доверие к разработчику
● Возможны конфликты с
пакетами дистрибутива
● Обычно свежие версии
**PPA (сообщество)**
● Низкий уровень доверия
● Нет поддержки
● Выбор в случае отсутствия
других вариантов

`Утилита apt (управление пакетами, работа с зависимостями, с репозиториями)`
● Автоматизированное управление пакетами с учетом зависимостей
● Работа с удалёнными репозиториями
● apt search package_name — поиск пакета по названию и описанию //проще найти на сайте разработчика ПО
● apt list package_name — поиск пакета по имени (названию) //найдет конкретный пакет
  * может быть запись об установке/установке автоматически
  * apt list vitrualbox* - все, что начинаетяс на ...
● apt show package_name — посмотреть информацию о пакете
  * depends (зависимости) из отчета - все пакеты, которые прилетят вместе с ним
● apt install package_name -y — установить пакет (-y - установка без подтверждения)
* apt reinstall package_name - переустановить (когда, например, удалил случайно файл этого пакета)
● apt remove package_name — удалить пакет, при этом сохранятся файлы с настройками
  * sudo apt remove nginx
  * доудалить все файлы с зависимостями: **apt autoremove** (удаляет пакеты, которые прилетели с основным пакетом, но когда основной пакет уже удален)
● apt purge package_name — полностью удалить пакет, включая конфигурационные файлы
  * apt purge name name name - имена всех пакетов (будут указаны при удалении главного пакета в консоли), чтобы удалить все конфиги
● apt upgrade — обновить все установленные пакеты
● apt update — обновить информацию о пакетах в репозиториях,
указанных в настройках
* apt edit-sources - можем допилить новые репозитории (но не забыть добавить ключ)
`Чтобы обновить версию ОС`: изменить jammy в открывшимся файле по sudo apt edit-sources  
 + после изменения в файле команда: distupgrade

`Утилита dpkg (для прямого ручного управления)`
● Ручное управление пакетами
● Нет работы с зависимостями
● Локальные пакеты
● dpkg -l — просмотр списка пакетов
● dpkg -i package_name — установить пакет или группу пакетов (название файла можно увидеть при его скачивании с помощью wget)
  * wget ссылка - перед этим скачать файл с сайта разработчика ПО (скопировав гипперссылку)
  * после устновки обнаруживается, что есть проблема с неустановленными зависимостями. Решение: apt -f install
● dpkg -r package_name — удалить пакет или группу пакетов


`Snap - пакеты` (все зависимости идут вместе с основным пакетом)
● Все зависимости – в пакете
● Пакет изолирован от системы – разрешения
● Программы запускаются дольше
● Больше потребление ресурсов
● Нет проблем совместимости
● snap search package_name — поиск пакета
● snap install package_name — установка пакета
● snap refresh package_name — обновление пакета
● snap remove package_name — удаление пакета
● snap list — просмотр установленных пакетов
* snap info

### Планировщик задач Cron  

https://crontab.guru/  //manual, можно выставить параметры и посмотреть какой по факту рельзультат по периодчиности  


* Можно сделать выполнение скрипта по расписанию, а в самом скрипте уже написать какой-либо длинный алгоритм
● Выполнение регулярных задач по расписанию
● Автоматизация обслуживания системы или приложений
● Системные задачи: //запускаются при работе всех пользователей (задачи root)
○ /etc/crontab
  * /etc/cron.daily/ // ежедневные задачи и т.д., можно создать собтвенный скрипт, который будет выполняться ежедневно
○ /etc/cron.d/* // здесь находятся дополнительные расписания, а не исполняемые файлы. Дополнительные скрипты с регулярными задачами допиливаются сюда, чтобы не засорять crontab (основной системный файл)
● Пользовательские задачи: //запускаются при работе конкретного пользователя
○ /var/spool/cron/crontabs/
○ управление: утилита crontab

`Формат задачи в Cron`
Пример: 17*** root cd / && run-parts --report /etc/cron.hourly  
1. Расписание (первые 17 символов)
✖ минуты
✖ часы
✖ день месяца
✖ месяц
✖ день недели
2. Пользователь (root характерен для системных задач)
✖ для выполнения команды
3. Команда (не должна требовать каких-либо подтверждений у человека, должна работать автономно)
✖ для задачи

`Утилита crontab` (позволяет работать от имени текущего пользователя)
● crontab -l вывести содержимое текущего файла расписания
● crontab -r удаление текущего файла расписания:
● crontab -e редактирование текущего файла расписания (если он не существует, то будет создан)
  * 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/ //tar - архиватор. здесь будет создаваться архив всех папок в домашней дерриктории. Нужно понимать, если ли права у текущего пользователя на выполненине заданной команды или нет. Здесь - 0 минут, 5 часов утра, в первый день недели (0 - Sunday, 1 - Monday)
  * Чтобы делать каждую минуту: * * * * * ...echo...
  * Чтобы прописать команду sudo внутри crontab, нужно вызвать sudo crontab -e сразу
● sudo crontab -u username – работа с файлом расписания другого пользователя

**Крч, установка пакета (не стандартного)**  
1. Добавить адрес репозитория в отдельный файл
2. Скачать ключ в папку с ключами (читай инструкцию на сатйе разработчика ПО)
3. sudo apt update
4. sudo apt install package_name

**Установка софта через .deb файл**
1. Качаем файл с оф сайта
2. sudo apt install /home/vadim/Загрузки/zoom_amd64.deb (через apt все зависимости будут удовлетворены, в отличии от dpkg)

**Пакет gnome-tweaks - для клавиатуры и хоткеев**
  * sudo apt install gnome-tweaks

### Сеть в Linux

---

`Архитектура сетевой системы:`
1. Сетевая карта (wi-fi адаптер и т.д.)
2. Ядро (сосредоточение программного кода, работающего с сетью)
3. Приложение (веб-сервер, браузер)

`Сетевые уровни и протоколы`
Есть 2 модели:  
1. OSI Basic Reference Model (7 уровней протоколов)
2. TCP/IP Model (4 уровня протоколов)

`Виды IP-адресов:  `
* IPv4
* IPv6

`Транспортировкой занимаются протоколы:`
+ TCP - более надежный
+ UDP - доставляет то, что может

`Сетевые интерфейсы и команда ip` //состояние сетевых настроек
● ip a – список всех интерфейсов
  * 1 строка - интерфейс, флаги, настройки
  * 2 строка - mac-адрес, настройки для широко-вещательных пакетов
  * 3 строка - уровень ip: ip с маской подсети (/24). Маска подсети определяет сколько символов выделяется на сеть, а сколько на адрес хоста, brd (бродкаст) ip адрес, настройки этого ip-адреса
  * 4 строка - свойства ip
  * 5 строка - настройки
● ip -s a – показ статистики (по количеству переданных пакетов и ошибок)
● **ip -c -s a – включение подсветки**
● ip a show enp0s3 – данные по одному интерфейсу
  * интерфейс lo (loop back) - локальный интерфейс
● ip link show enp0s3 – данные уровня L2 (link)
● ip r – просмотр информации о маршрутах
  1. default - шлюз, с помощью которого мы отправляем пакеты за пределы локальной сети
  2. наша локальная сеть
  * другие сети
* ip netns list // netns - (для работы с пространством имен Network) список пространств имен определенного типа
  * ip netns add testns //добавить новое пространство имен типа Network - создается файл с именем test в vat/run/netns

*флаги сетевых интерфейсов:*  
+ UP - работает
+ LOWER_UP - работает на физ. уровне (кабель подключен) 

*IP-адреса*
* данимические - его нам выделяет сервер, к которому мы подключаемся
* статические - прописан у нас

`Сокеты и порты (уровень TCP - транспортный уровень)`
● ss – socket stat
● ss -ntlp – TCP-сокеты в состоянии LISTEN
  * -n - показать все в цифрах без текстового сопровождения
  * -t - TCP протокол
  * -l - listen сокеты (те, которые в состоянии прослушивания)
  * -p - указать программы, которые привязаны к этому сокету
● ss -ntulp – TCP и UDP-сокеты в состоянии LISTEN
  * -u - добавить UDP-сокеты
● ss -tulpan – Все TCP и UDP-сокеты //чтобы показать все сокеты в любых состояних

Сокет - сочетание ip-адреса и порта для конкретного протокола  

`Конфигурация сети в Ubuntu` - настройка адаптеров, маршрутизации, DNS-серверов
https://netplan.io/

Netplan:  
1. systemd-networkd //для конфига бэкэнда
2. Network Manager

**Netplan**  
● /etc/netplan/*.yaml – конфигурационные файлы
  * каждый новый уровень конфигурации имеет отступ в 2 пробела
● netplan try – тестирование и применение конфигурации //если мы потеряем соединение и не увидим сообщение о подтверждении, конфиги откатяться через 2 минуты
● netplan apply – применение конфигурации
● Конфигурация по умолчанию:
# Let NetworkManager manage all devices on this system
network:
 version: 2
 renderer: NetworkManager

**Netplan – конфигурация с DHCP**  
Пример для бэкэнд конфигурации серверной Ubuntu:  
network:  
2п version: 2  
2п renderer: networkd  
2п ethernets:  
4п enp0s3: //конкретная конфигурация интерфейса enp0s3  
6п dhcp4: yes  //получить адрес автоматически  
6п nameservers:  
8п addresses:  //конфиг для DNS
10п - 8.8.8.8  
10п - 8.8.4.4  

**Network Manager - статическая конфигурация**  
network:  
 2 version: 2  
 2 renderer: networkd  
 2 ethernets:  
 4 enp0s3:  
 6 dhcp4: no  //отключаем динам ip  
 6 addresses: [192.168.1.84/24]  //можно несколько ip-адресов, тогда перечислить через запятую
 6 routes:
 8 to: default
 8 via: 192.168.1.1  
 6 nameservers:  
 8 addresses:  
 10 - 8.8.8.8  
 10 - 8.8.4.4  
 **Для конфигурации виртуальной машины:** //стандартный nat
 + ip route - оттуда берем via, addresses: ip справа в строчках, и шлюз как во второй строке (24). to: 0.0.0.0/0

**Диагностика сети**  
● ping 8.8.8.8 – доступность хоста (ICMP протокол) //можно указать ip, публичный адрес, локальную сеть 
  * ping 10.0.0.33 -c2 //2 sec 
● ping ya.ru – проверка DNS и доступности
● host -t a yandex.ru – проверка DNS
  * -t a - получить ip-adress от домена
● host -t a yandex.ru 8.8.8.8 – другой DNS-сервер
● dig @8.8.8.8 google.com – подробная информация по DNS
● tracepath ya.ru – просмотр маршрута прохождения пакетов
● traceroute ya.ru – альтернатива //нужно доустанавливать  
● mtr ya.ru – постоянный мониторинг доступности хостов
* resolvectl dns - покажет состояние тех адресов, которые настроены для преобразования имен в ip-адреса

> /etc/hosts - для указания ip-адресов вручную для DNS-серверов. Адреса, указанные в этом файле перебивают реальные. Например: если указать ya.ru, будем обращаться к себе, а не удаленно в яндекс  

`Фильтрация пакетов` (про безопасность)  **Firewall** Все правила - до первой перезагрузки   
настройка просходит с помощью утилиты iptables  
● Просмотр таблицы
○ iptables -L -nv 
  * -L показать список правил по таблице фильтр
  * -nv - численный вид, большая детализация
○ iptables -L -nv -t nat
● Политика по умолчанию - выполняется, если пакет не подходит ни под одно из правил
○ iptables -P INPUT DROP
  * INPUT DROP - выкидывать все пакеты, если они не попали под правила
● Добавление правил
○ iptables -A INPUT -p tcp --dport 80 -j ACCEPT
  * -A - (append) добавить правило в конец списка
  * -j - это выполняемое действие. ACCEPT - принять
  * -p - протокол
  * --dport - порт назначения (входящий). --sport - для исходящего травиха
○ iptables -I INPUT -p tcp --dport 80 -j ACCEPT
  * -I - (insert) добавить правило в начало списка
○ iptables -A INPUT -p tcp -s 192.168.0.100 --dport 80 -j DROP //такое правило следует располагать до разрешающих, иначе до него не дойдет
  * s - source ip (статический)
  * DROP - выкинуть именно для этого ip
● Удаление правил
○ iptables -D INPUT 3 //отсчет ведется с 1
  * 3 - порядковый номер правила
○ iptables -D INPUT -p tcp --dport 80 -j ACCEPT //можно указать все правило с его параметрами для удаления
● Сброс правил (!!!НО не срабиывает правила по умолчанию!!!)
○ iptables -F

Пример (настройка сервера):  
+ iptables -A INPUT -p tcp --dport=22 -j ACCEPT //22 - порт для ssh-трафика 
  * -p - протокол
+ iptables -A INPUT -p tcp -m multiport --dport 80,443 -j ACCEPT // разрашение связи с серверами с портами 80, 443
+ iptables -A INPUT -i lo -j ACCEPT //разрешение для внутр сети
  * -i - input interface  
+ iptables -I INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT //разрешить прием пакетов от соединений, к которым мы сами подключились
  * -m - модуль
+ iptables -A INPUT -p icmp -j ACCEPT //разрешить принимать пакеты протокола icmp
+ iptables -P INPUT DROP //добавляем правило по умолчанию по дропу всего остального. Извне просиходит тишина, скрытие существования нашего сервера

`Перенаправление портов`
● Редирект с 80 на 8080 порт (TCP):
○ iptables -t nat -I PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080
  * nat - одна из таблиц
● Проверка:
○ iptables -L -nv -t nat

`Сохранение конфигурации iptables`
● Сохранение и восстановление из файла
○ iptables-save > iptables.rules
○ iptables-restore < iptables.rules
● Сервис netfilter-persistent //Чтобы автоматизировать восстановление настроек для firewall  
○ apt install iptables-persistent netfilter-persistent
○ netfilter-persistent save
○ Конфигурация в /etc/iptables


---

### Сервер

Веб-приложение:   
+ Frontend  (Веб-браузер, клиентский код)
+ Backend  (Веб-сервер, серверный код)
+ База данных
+ HTTP(S) - для взаимодейсвтия фронтенда с бэкэндом, S - расширение (SSL/TLS - защищенное соединение)

HTTP - запрос состоит:  
1. Request Line - запрос
2. Заголовки запросов
3. Разделитель
4. Тело запроса (может быть пустым)

HTTP - ответ состоит:
1. Версия протокола, код ответа (код ошибки), статус сообщения
  * 200-тые - все ок
  * 300 - редирект (перенаправление запросов)
  * 400 - ошибки
  * 500 - серверные ошибки
2. Заголовки ответов

`Консольные утилиты для Web` (тестирование сервера в консоли)
○ curl -L https://ya.ru/
  * -L покажет контент сервера прямо в консоли (в текстовом виде). (Проверка работы сервера)
○ wget https://yastatic.net/jquery/2.1.4/jquery.min.js //утилита для скачивания

`Протоколы SSL/TLS и HTTPS`
● SSL — первые версии защищенного протокола
● TLS – (transport layer security) современный протокол
● HTTPS – работа протокола HTTP поверх защищенного
канала SSL/TLS
● HTTP/2, HTTP/3 – по умолчанию используют
защищенный вариант

`Схема работы HTTPS:`  
Список доверенных центров (Root CA) <-- `Веб-браузер` --> (ключ шифрования) --> <-- Сертификат -- `Веб-сервер` <-- выдача сертификата <-- (СА - удост.центр)  

Преимущества HTTPS:  
● Трафик шифруется при передаче
○ Нет перехвата данных
○ Нельзя изменить содержимое
● Подтверждение соответствия сервера домену
● Надежная доставка через цепочку хостов
● Поддержка новейших веб-технологий

`NGINX - самый популярный веб-сервер в мире`  
● Самый популярный сервер в мире
● Высокая производительность
● Масштабируемость по количеству подключений
● Открытый продукт (коммерческий Nginx Plus)
● Широкая функциональность
● Модульная архитектура
● Поддержка новых технологий
● Используется как сервер для статики, прокси, кэширующий сервер
● Не исполняет серверный код веб-приложения
● Разработчик первых версий: Игорь Сысоев

**Настройка конфигурации NGINX**  
● Установка: sudo apt install nginx
1. Тестирование конфигурации: sudo nginx -t //после любого редактирования основного файла
2. Применить новые конфиги: sudo systemctl reload nginx //без перезагрузки
● Конфигурация: /etc/nginx/*
  * modules-available - конфиги сайтов
  * modules-enabled - символические ссылки на сайты (для возможности их оперативного отключения, просто удаляется ссылка)
● **Основной файл:** /etc/nginx/nginx.conf
● Блоки: server {}
● Директивы: server_name site.ru; //точка с запятой для директив обязательна  
● Переменные: $uri
● Документация: http://nginx.org/ru/docs/ //КАРЛ! ОСНОВНОЙ ЯЗЫК - РУССКИЙ

`Файл конфигурации NGINX: /etc/nginx/nginx.conf`
+ 1 строка - пользователь (от этого зависят права сервера и то, какие директории он может читать)
+ 4 строка - подключаем модули именно тут 
+ Блок events: только здесь можно указать worker connections  
+ Блок http: вся работа с вебом
  * директивы могут повторятьс, но чем вложеннее директива - тем выше ее приоритет
  * access_log - пишет буквально все, что пришло на вход
  * error_log - пишет все ошибки
  * gzip - конфигурационные директивы про сжатие
+ Блок mail: работа с почтой

**Пример конфига NGNIX**
server {  
listen 80 default_server;  //привязываем сервер к конкретному порта/ip-адресу
listen [::]:80 default_server; //настройка для IPv6
root **/var/www/html**  //корень сервера  //здесь же хранятся файлы PHP
index index.html index.htm index.nginx-debian.html;  //дефолтные директивы
server_name _;  //доменное имя, можно несколько
location / {  //отвечает за запросы
try_files $uri $uri/ =404;  //1uri - поиск по адресу, 2uri - поиск такой дирректории
}  
}  

**проверить работу nginx**  
+ ps afx (2 крайних процесса)  
+ ss -ntlp (2 сокета - под IPv4/IPv6)  
+ curl localhost //проверка локальной работы

`Веб-сервер Apache` актуальная версия 2.4 (на 16.07)  //в CamelCase  
● Популярный веб-сервер
● Открытый продукт
● Максимальная функциональность
● Модульная архитектура
● Разные режимы работы (MPM – prefork, event…)
● Плохая масштабируемость по соединениям (prefork)
● Возможность исполнения серверного кода (модули)
● Исполняет роль backend-сервера
● Документация: https://httpd.apache.org/docs/2.4/en/

`Конфигурация Apache`
● Установка: sudo apt install apache2
* ps afx - проверить процессы. Если установлен nginx, порт 80 уже может быть занят
* ss -ntlp - смотрим занятые сокеты
● Тестирование конфигурации: sudo apachectl -t
● Применить: sudo systemctl reload apache2
* Попробовать запустить: sudo systemctl start apache2
* Остановить: sudo systemctl stop apache2
* Диагностика проблем: sudo systemctl status apache2
● Конфигурация: /etc/apache2/*
  * ports.conf - конфиг портов - может понадобиться изменить порт.
  * после изменения порта - sites-enabled - изменить порт
● Основной файл: /etc/apache2/apache2.conf
● Блоки: <VirtualHost></VirtualHost> //первые скобки блок открывается, вторые - закрывается. Между ними - директивы 
● Директивы: ServerName site.ru (без точки с запятой)
● Документация: https://httpd.apache.org/docs/2.4/en/

`Пример конфигурации Apache`
Listen 8081  //8081 - потому что порт 80 уже занят
<VirtualHost *:8081>  
ServerName www.example.com //доп имена прописываются в отдельные строки
ServerAdmin webmaster@localhost  //в сообщение об ошибке  
DocumentRoot /var/www/html  //корневая директива
ErrorLog /var/log/httpd/error.log  
CustomLog /var/log/httpd/access.log combined  
</VirtualHost>  

Reverse proxy:
1. Браузер
+ Выполняет клиентский код
+ отображает интерфейс
2. Nginx (frontend)
● Обрабатывает соединения
● Отдаёт статику (CSS, JS,
картинки)
● Проксирует динамические
запросы
3. Apache (backend)
● Обрабатывает
динамические запросы
● Исполняет серверный код
(PHP, Perl, Python)
● Возвращает ответ Nginx

Пример конфигурации Nginx для reverse proxy:
`Динамические запросы`
location / {  
proxy_pass http://localhost:8080;  
//дальше идут параметры запроса для апачи
proxy_set_header Host $host;  
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  
proxy_set_header X-Real-IP $remote_addr;  
}  

`Статические запросы`  //любой блок с регулярным выражением рассматривается сначала
location ~* ^.+.(jpg|jpeg|gif|png|ico|css|zip|pdf|txt|tar|js)$ {  //~* значит регулярное выражение, далее - само оно, $ - означает, что запрос должен заканчиваться этим  
 root /var/www/html;  
}  

**ПРАКТИКА ПО НАСТРОЙКЕ РЕВЕРС ПРОКСИ:**  
В VirtualBox: Сеть - если NAT -> доп.настройки -> проброс портов -> 1. порты: 9080 - 80 (nginx) //NAT предполагает сетевой инет  
  * localhost:9080 в браузере - для отображения сайта
  * сетевой мост - будет отвечать по параметрам апачи
  * F12 - в браузере для режима разработки -> сеть
  * проверяемые файлы в /var/www/html/
    * тут же можно новые папки с файлами и т.д. Крч пилить сайт
  * настройка сокета PHP-FPM по конфигу пула... (найти listen: и путь к фалу, 36 стр)
  * редактируем конфиг sites-enabled
  * из винды: http://192.168.1.84:80/info.php

**Обработка PHP в Apache**
● Установка: apt install libapache2-mod-php8.1 php8.1
● Обработка PHP подключается автоматически, по расширению файла
  * etc/apache2/mods-enabled/ - туда добавился php
● Файл для проверки:
<?php  
phpinfo();  
?>  
● Проверяем: curl http://localhost/info.php

**Обработка PHP в PHP-FPM**
● Установка: apt install php8.1-fpm
● Замена Apache для работы с PHP
● Связь между Nginx и PHP-FPM через UNIX-сокет
● Обработка происходит с помощью location в Nginx
* Конфиг пула: /etc/php/8.1/fpm/pool.d/www.conf
location ~ \.php$ {   
include snippets/fastcgi-php.conf;  
root /var/www/html;  
fastcgi_pass unix:/run/php/php8.1-fpm.sock;  
}  

`СУБД MySQL`
● Самая популярная СУБД для веб-приложений
● Клиент-серверная архитектура
● Несколько веток развития:
○ `Oracle MySQL`
○ Percona Server for MySQL
○ MariaDB
● Поддержка транзакций
● Репликация
● Поддерживает синтаксис SQL с расширениями
● Документация: https://dev.mysql.com/doc/refman/8.0/en/

`Установка MySql и первые шаги`
● Установка: apt install mysql-server-8.0
* Status: systemctl status mysql
● Заходим в консоль MySQL: sudo mysql
● Переходим в системную БД mysql: use mysql;
● Получаем список пользователей: SELECT * FROM user\G
  * G - консольный формат вывода
● Создаём новую базу данных: CREATE DATABASE gb;
● Создаём таблицу: CREATE TABLE test(i INT);
  * CREATE TABLE IF NOT EXISTS test (id PRIMARY KEY AUTO_INCREMENT, name VARCHAR (256), age INTEGER_UNSIGNED); автоинкремент - для автоматического увеличения
● Создадим записи в таблице: INSERT INTO test (i) VALUES (1),(2),(3),(4);
  * INSERT INTO games VALUES (NULL, "World_of_Warcaft", "MMORPG"), (NULL, "Lineage_2", "MMORPG");
  * под столбцы с автоинкрементом - значения NULL
● Сделаем выборку из таблицы: SELECT * FROM test;
* Основной порт: 3306, по дефолту можем зайти только с локал хоста
* show databases; посмотреть таблички
* use mysql; перейти в БД
* show tables; посмотреть список таблиц

**Web-интерфейс для управления MySQL**: apt install phpmyadmin
  * конфиги (пароль): /etc/phpmyadmin/config-db.php
1. Решение проблемы с запуском phpmyadmin in a browser:  
Идем:  
sudo nano /etc/apache2/apache2.conf  
В конец файла добавляем   
Include /etc/phpmyadmin/apache.conf  
Перезапускаем сервис  
sudo systemctl restart apache2.service  
в браузере: ip/phpmyadmin, пример: http://192.168.1.84:8080/phpmyadmin/  

2. Решение проблемы "Нет привелегии для создания базы данных":  
mysql -u root
CREATE USER 'rootuser'@'localhost'IDENTIFIED BY 'testpassword'; //создали нового пользователя, хз зачем
GRANT CREATE ON *.* TO 'rootuser'@'localhost'; //дали пользователю грант на создание баз данных
FLUSH PRIVILEGES; //сохранить привелегии пользователей


---

`DOCKER`- это платформа, предназначенная для быстрой разработки, развертывания, тестирования и запуска приложений в контейнерах. (сам создает пространства имен для контейнеров и прописывает ограничения контрольных групп)
Начало: https://docs.docker.com/get-started/  
**Контейнер** - упакованное приложение + библиотеки, полностью изолирован от хостовой ОС Linux. Сам контейнер, по сути, содержит операционную систему, за ислючением самого ядра и некоторых низкоуровневых компонентов
  * запускаются из образов в неограниченном количестве
- это, по сути, набор утилит для управления контейнерами 
- контейнеры бывают многослойными (что это дает? - следующие версии контейнеров наслаиваются)
- изолирован не только в плане файловой системы, но и в плане сети

**Докер-демон** - управляет всему сущностями докера, программная платформа для работы с образацами и контейнерами

**Контейнеризация**
● Быстрое развёртывание приложений из образов
● Полная повторяемость при запуске (надёжность)
● Высокая скорость запуска и удаления контейнеров
● Низкие накладные расходы на виртуализацию // производительность не падает
● Возможность преодоления несовместимости софта и ОС //внутри контейнера можно запустить любое приложение, даже если наша ОС не соответствет
● Автоматизация операций управления приложениями //каким-то образом исключаются ручные операции

`Архитектура Docker:`
1. Клиент (терминал/удаленный API)
2. Хостовая система с  (скачивание, установка и сбор контейнеров, запуск)
  * в демоне есть образы, из которых мы можем запустить неограниченное количество контейнеров
3. Реестр образов (Docker Hub) - находится в интернете (общедоступен)

`Реестр образов Docker Hub` - репозиторий
● Реестр по умолчанию в Docker
● Веб-интерфейс: https://hub.docker.com/
  * Explort -> образы (справа вверху команда для установки), также обращать внимание на ограничение по архитектуре (amd64, ...)
● Официальные образы (official image) .//безопасность ++
● Теги (latest, 0.4-alpine) //версия софта + образ дистрибутива
● Документация к образам //может содержать параметры для запуска
* Образ имеет слоеную струкутуру: 1 слой - базовый, остальные - изменения в него

`Запуск тестового контейнера`
● Установка Docker: apt install docker.io
● Проверка: sudo docker
● Создание и запуск контейнера: docker run hello-world //run - создание+запуск контейнера (2в1)
  * если не указывает тег версии образа - по умолчанию тег: latest

**Команды Docker:**  
* запуск уже установленных контейнеров: docker start name
* docker ps - список активных контейнеров
  * docker ps -a - все контейнеры //столбец name генерирует имя рандомно
● docker images – список образов
  * docker rmi images \$(docker images -aq)
● docker search nginx – поиск образа на удаленном репозитории докера
● docker pull nginx – скачивание образа. Если уже был образ, но более старой версии - он обновится на latest. 
  * docker pull ubuntu - по дефолту latest
  * docker pull ubuntu:18.04 //с использованием тега
* docker run -it ubuntu bash//-it - интерактивный режим - запускаем и входим в него (то есть не в  фоновом режиме), bash - оболочка - то есть проваливаемся внутрь контейнера
  * добавить --name name //именованный контейнер
  * будет запущен до того момента, пока что-то делает. Можно добавить "sleep 60" - будет активен в течении 60 сек после запуска
● docker start|restart|stop nginx – операции с контейнером, которые работают в режиме демона
● docker rm 9cbf7c3230d0 – удаление контейнера
  * указываем либо id, либо имя 
  * docker rm \$(docker ps -aq) //удалить все контейнеры
● docker rmi hello-world – удаление образа
  * dockdr rmi ubuntu:18.04 // с тегом
● docker logs nginx1 – просмотр логов контейнера
* docker history name //какие этапы проходил контейнер при сборке (docker build). Если размер в записи > 0, то это новый слой
* docker inspect infinite //информация о контейнере
* docker rename gallant_feistel geek_brains //переименовать контейнер
* docker system df //место, занимаемое контейнерами и образами на жестком диске
* docker system prune -af //удалить все неиспользуемые контейнеры и образы

> docker "команда" --help - покажет варианты использования с флагами

`Типы сетей Docker:`
● Bridge — `сети по умолчанию`, аналог типа подключения NAT в
VirtualBox. //контейнер имеет доступ к внешней сети, но попасть внутрь без проброса портов нельзя
● Host — с помощью этого драйвера контейнер получает доступ к
собственному интерфейсу хоста. Аналог подключения «Мост» в
VirtualBox. //обращение напрямую к сокетам (так же, как работает обычное приложение)
● Macvlan даёт контейнерам прямой доступ к интерфейсу и субинтерфейсу (VLAN) хоста.
● Overlay позволяет строить сети на нескольких хостах с Docker.

`Тома и монтирование в Docker`
* Bind mount (монтирование) подключение любой папки (как общие папки в вирт.машине) /var/www -> /var/nginx/ (Контейнер Nginx)
  * можно подмонтировать и отдельные файлы (прописать в конфиге внутри контейнера include)
  * необходимо выдать права на чтение веб-серверу
* Docker volume (том Docker) /var/lib/docker/volumes/xxxxx -> /var/nginx/ (Контейнер Nginx)

**Запуск Nginx – проброс портов и директории**
● Команда создания и запуска: docker run -d --restart always --name nginx1 \
-p 80:80 -v /var/www/html:/usr/share/nginx/html nginx
  * -d - в режиме демона
  * --restart always - перезапускать всегда вместе с системой
  * nginx1 - новое имя контейнера
  * -p 80:80 - проброс портов для работы в режиме "Bridge" (первая цифра - порт на хостовой системе, вторая - внутри контейнера)
  * -v /var/www/html:/usr/share/nginx/html - подключение локальной директории к внутренней директории контейнера
  * nginx - образ iso nginx, который нашли и запулили (pull) через поиск
* Запуск контейнера с туториалом: docker run -d -p 9180:80 docker/getting-started
● Учитываем порты на хосте (ss -ntlp)
● Монтируем директории
● Активируем автозапуск
● Контейнер работает в режиме демона
● Сеть по умолчанию (bridge)

`Работа внутри контейнера`
● Не рекомендуется в реальной работе
● Заходим: docker exec -ti nginx1 bash
  * exec - запустить
  * -ti - терминал + интерактивный режим ()
  * nginx1 - контейнер
  * bash - команда (bash - получаем оболочку внутри контейнера)
● Смотрим настройки: ls -al /etc/
  * /docker-entrypoint.sh - в корневой, скриптовый файл, занимается запуском приложения внутри контейнера
● Версия базового дистрибутива: cat /etc/os-release
● Настройки nginx: ls -al /etc/nginx/
  * конфиг осн. сайта: /etc/nginx/conf.d/  //содержит инфу о корневой директории для монтирования извне
● Директория сайта: ls -al /usr/share/nginx/html/ // будет содержать файлы из примонтированной папки из хостовой сис-мы. Таким образом, если меняем конфиги сайта - меняем их во внешней среде, не изменяя структуру контейнера

`Docker compose` - для запуска нескольких контейнеров одновременно. Кроме того, сам скачает образ и создаст эти контейнеры  
● Запуск нескольких контейнеров одной командой
● Декларативная конфигурация
● Формат YAML (отступы, вложенность)
● Автоматизация запуска систем контейнеров

`Синтаксис docker-compose.yml`  
version: '3'  //зависит от версии докер-компоус  
services:  
 wordpress:  
 depends_on:  
 - db  
 image: wordpress:5.3.2-fpm-alpine  
 container_name: wordpress  
 environment:  
 - WORDPRESS_DB_HOST=db:3306  
 volumes: //подключаемые тома. сам топ -> куда пробрасывается  
 - wordpress:/var/www/html  
 networks: //внутренняя сеть  
 - app-network  

 `Команды Docker Compose`
//для начала - создать файл docker-compose.yml  и запилить в него конфиги
● apt install docker-compose – установка
● Проверка yml: apt install yamllint //пакет для проверки синтаксиса языка yaml
● docker-compose up -d – создание и запуск //запускать команду в директории с созданным yaml файлом докер компоуза
● docker-compose ps – список контейнеров
● docker-compose down – остановить и удалить
● docker-compose stop – остановить
● docker-compose start – запустить
● docker-compose rm – удалить остановленные

Пример простейшего конфига:                                       
version: '3'  
services:  
  nginx:  
    image: nginx:latest  
    ports:   
      - 9080:80  
    volumes:  
      - /var/www/html:/usr/share/nginx/html  

**WordPress** — бесплатная система управления контентом (CMS) с открытым исходным кодом, которая опирается на базу данных MySQL и обрабатывает запросы с помощью PHP.


