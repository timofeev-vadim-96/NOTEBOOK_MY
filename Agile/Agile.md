Препод: Игорь Зуриев (декан факультета ГБ "Руководитель проектов в строительстве")

**IT-продукт** - Любое программное обеспечение, сайт,
мобильное приложение и другая IT система, которая разрабатывается
и внедряется для выполнения определённых функций.

**Жизненный цикл продукта** - Это этапы, через которые IT-продукт проходит
от начала создания до конца разработки и внедрения в бизнес-среду

**Этапы жизненного цикла IT-продукта:**
1. Подготовка (зарождение идеи, формирование визуального образа ПО)
  * Анализ конкурентов
  * Сбор информации
  * трафик конкурентов
  * ассортимент
  * функционал
2. Проектирование
  * архитектура проекта (приложение)
  * выбор дизайна
  * выбор подрядчика
3. Разработка
  * написание кода
  * отрисовка дизайна
  * составление документации
4. Тестирование
5. Поддержка
  * новые способы оплаты
  * исправление багов
  * добавление функционала
  * добавление ассортимента
  * учитывание обратной связи от пользователей

Этапы жизненного цикла по SDLC:
1. Анализ
2. Планирование
3. Проектирование
4. Разработка
5. Тестирование
6. Развертывание

## Модель и методология разработки IT-продукта

**Модель** -  Описывает, какие стадии
жизненного цикла продукт проходит
и что происходит на каждой из них

MVP - минимальная версия продукта  

**Методология** // более практичная история 
- Набор методов по управлению
разработкой: это правила, техники
и принципы, которые делают её более
эффективной и приводят к получению
качественного продукта в результате.

`Модели разработки ПО:`  
✔ `«Waterfall Model»/каскадная` - традиционная разработка, СТАНДАРТ МО США в 70-80гг.  //обратная связь от заказчика уже после разработки продукта :(
  * последовательное выполнение фаз проекта: 
    1. Прототипирование
    2. Дизайн
    3. Код
    4. Тестирование
    5. Поддержка

> переход к след этапу только после предыдущего

Плюсы:  
+ Разработку легко контролировать
+ Стоимость проекта определяется на начальном этапе
+ Не нужно нанимать тестировщиков с серьезной технической подготовкой
+ Хорошо работает тогда, когда есть четкие требования и видение итогового продукта

Минусы:  
- Тестирование начинается на последних этапах разработки
- Заказчик видит готовый продукт в конце разработки и только тогда дает обратную связь
- Разработчики пишут много тех. документации, что задерживает сроки
- Нельзя скорректировать требования к продукту и нельзя откатиться по стадиям жизненного цикла

Waterfall применяется в: //из-за наличия большой базы законодательных и нормативных документов  
* Строительстве
* Медицине
* Космической отрасли

✔ `V-образная модель` (разработка через тестирование) - это та же каскадная модель, в которой кроме требований дополнительно описывается как будет тестировать ПО на этапах разработки

V-образная модель применяется в: //в системах, в которых важно бесперебойное функционирование, хз почему, якобы из-за цены ошибки буквально в человеческие жизни, поэтому происходит супер тщательное тестирование буквально на каждом этапе
* Прикладные программы в клиниках для наблюдения за пациентами
* Интегрированное ПО для механизмов управления аварийными подушками безопасности в ТС

Плюсы: те же, что в Waterfall + количество ошибок в архитектуре сводится к минимуму
Минусы: Стоимость ошибки при разработке архитектуры также будет высока

✔ `Спиральная модель` (разработка версиями), каждый виток спирали - waterfall model //постоянная оценка рисков
  * каждый очередной продукт разрабатываетя на базе первого
  * вначале каждого витка спирали происходит оценка рисков и выгоды

Плюсы:  
+ уделяется большое внимание проработке рисков

Минусы:  
- риск застрять на начальном этапе разработки (бесконечно совершенствовать первую версию продукта)
- разработка длится долго и стоит дорого

Пример применения: система умный дом, где каждый элемент, с которым мы сможем взаимодействовать, разрабатывается с каждой новой версией ПО

✔ `Инкрементная модель` (каждый инкремент - новая версия ПО с новым функционалом) //изначально все также очень четкое ТЗ
* требования делятся на сборки
* поэтапная сборка ПО
* каждый модуль проходит через ватерфолл систему
* предполагает, что первый большой модуль родит ПО с базовым функционалом
* остальные модули - "инкременты"
* продолжение процесса до момента создания "полной" системы

Пример проекта по `инкрементной` модели:  
1. Заказчик написал ТЗ.
2. Программисты предложили реализовать основные функции, а затем протестировать
на пользователях, «взлетит или нет».
3. Продукт разработан и его запускают на рынок.
4. Если пользователям соцсеть нравится, работа над ней продолжается, но уже
 по частям.
5. Программисты параллельно создают функциональность для загрузки фотографий,
обмена документами, прослушивания музыки и других действий, согласованных
 с заказчиком.
6. Продукт совершенствуется инкремент за инкрементом, приближаясь к
изначально созданному ТЗ.

Плюсы: 
✔ не нужно сразу вкладывать много денег
✔ можно быстро получить фидбэк от пользователей и обновить ТЗ
✔ снижается риск создать продукт, который никому не нужен
✔ ошибка стоит дешевле

Минусы:
✖ над продуктом работают несколько команд программистов – каждый видит продукт по своему
✖ разработчики будут оттягивать доработку основной функциональности и «пилить мелочёвку»
✖ подходит для проектов, в которых точное ТЗ прописано уже на старте, а продукт должен быстро выйти на рынок

✔ `Итеративная или итерационная модель` //ТЗ может быть не четким, видение продукта рождается в процессе разработки
● Не требует для начала проекта полной спецификации требований
● Создание начинается с реализации части функционала
● Эта часть функционала становится базой для определения дальнейших требований
● Этот процесс повторяется
● Версия может быть неидеальна, главное, чтобы она работала
● Понимая конечную цель, мы стремимся к ней так, чтобы каждый шаг был результативен, а каждая версия — работоспособна

Плюсы:  
✔ Быстрый выпуск MVP
✔ Быстрая обратная связь от заказчика и пользователей
✔ Фокусировка на наиболее важных функциях ПО и улучшении их в соответствии с требованиями рынка и пожеланиями клиента
✔ Постоянное тестирование пользователями позволяет быстро обнаруживать и устранять ошибки

Минусы:
✖ Использование на начальном этапе баз данных или серверов — первые сложно масштабировать, а вторые не
выдерживают нагрузку. Возможно, придётся переписывать большую часть приложения.
✖ Отсутствие фиксированного бюджета и сроков – заказчик детально не знает, как выглядит конечная цель и когда
закончится разработка

Особенности: 
* подходит для работы над большими проектами с неопределенными требованиями/стартапы с MVP
* подходит для задач с инновационным подходом, когда заказчик не уверен в результате

-- **жесткие модели сверху**
✔ `Гибкие модели`, методологии и подходы
(Agile, Scrum, Kanban и другие)  

---

Манифест AGILE (кратко о главном) http://agilemanifesto.org/iso/ru/manifesto.html

## `AGILE` 

- (eng - "гибкий")- основа для гибких подходов и методологий, это ПОДХОД к разработке. Философия в том, чтобы ориентироваться именно на бизнес и рынок, а не на какое-то базовое ТЗ. Мы проверяем актуальность продукта и необходимость допиливания к нему каких-либо функций на основе рынка и фидбэка от пользователей
● Была создана на основе итеративной модели
● Это не модель и не методология, а подход к разработке
● Включает в себя практики, подходы и методологии, которые помогают создавать ИТ-продукт более эффективно

**Главня цель AGILE** - как можно быстрее поставить очередной ценный фрагмент продукта заказчику

AGILE **включает в себя** набор методологий: 
✔ Экстремальное программирование (Extreme Programming, `XP`)
✔ Бережливую разработку программного обеспечения (`Lean`)
✔ `Фреймворк для управления проектами Scrum` - четко прописывает все роли и процессы, которые происходят при разработке IT-продукта
✔ Разработку, управляемую функциональностью (Feature-driven development, `FDD`)
✔ Разработку через тестирование (Test-driven development, TDD)
✔ Методологию «чистой комнаты» (Cleanroom Software Engineering)
✔ Итеративно-инкрементальный метод разработки (OpenUP)
✔ Методологию разработки Microsoft Solutions Framework (MSF)
✔ Метод разработки динамических систем (Dynamic Systems Development Method, DSDM)
✔ Crystal
✔ Метод управления разработкой `Kanban` - включает в себя некоторые практические приемы
Принципы Kanban:
● Команда ведёт работу с помощью виртуальной доски, которая разбита на этапы проекта
● Каждый участник видит, какие задачи находятся в работе, какие — застряли на одном из этапов, а какие уже дошли до его столбца и требуют внимания. 

`Отличие SCRUM от KANBAN`
В отличие от Scrum, при использовании Kanban-подхода можно взять срочные задачи в разработку сразу,
не дожидаясь начала следующего спринта.

Как происходит разработка на AGILE:
1. Проходит через ряд циклов — итераций //первая итерация - MVP
2. Каждая итерация — это фактически отдельный проект
3. В рамках итерации разрабатывают фрагмент программы, улучшают функциональность, добавляют новые возможности

`Принципы Agile:` (4)
1. ЛЮДИ И ВЗАИМОДЕЙСТВИЕ важнее процессов и инструментов
2. РАБОТАЮЩИЙ ПРОДУКТ важнее исчерпывающей документации
3. СОТРУДНИЧЕСТВО С ЗАКАЗЧИКОМ важнее согласования условий контракта
4. ГОТОВНОСТЬ К ИЗМЕНЕНИЯМ важнее следования первоначальному плану

`Задачи, решаемые с помощью Agile:` (12)
1. Наивысшим приоритетом для нас является удовлетворение потребностей
заказчика, благодаря регулярной и ранней поставке ценного программного
обеспечения.

2. Изменение требований приветствуется, даже на поздних стадиях разработки.
Agile-процессы позволяют использовать изменения для обеспечения заказчику
конкурентного преимущества.

3. Работающий продукт следует выпускать как можно чаще, с периодичностью
от пары недель до пары месяцев.

4. Бизнес обязательно должен работать вместе с программистами, помогать им понять специфику данного рынка

5. Над проектом должны работать мотивированные профессионалы. Чтобы
работа была сделана, создайте условия, обеспечьте поддержку и полностью
доверьтесь им.
  * Руководитель прежде всего должен создавать условия для команды и обеспечивать всестороннюю поддержку,
проводить коучинг, следить за атмосферой в коллективе

6. Непосредственное общение является наиболее практичным и эффективным
способом обмена информацией как с самой командой, так и внутри команды.
  * Самый простой и эффективный способ узнать требования клиента, заказчика или пользователя – поговорить с ними.

7. Работающий продукт — основной показатель прогресса.
  * Степень готовности проекта должна измеряться не словами о том, что ТЗ уже написано и 50% макетов нарисовано,
а количеством функционала, выпущенного в production.

8. В Agile важен ритм, постоянные улучшения.
  * Бизнес и программисты всегда должны располагать возможностью делать процесс устойчивым, постоянно его улучшать.

9. Agile вообще не будет работать, если вы написали кривой код. (нужно соблюдать SOLID)
  * У вас должна быть хорошая гибкая архитектура, в которую можно добавлять разные элементы и,
при необходимости, легко их изменять.

10. Простота — искусство минимизации лишней работы — крайне необходима. Она проявляется
в технической составляющей, в дизайне.

11. Самые лучшие требования, архитектурные и технические решения рождаются у самоорганизующихся команд.
  * Нужен коуч в лице менеджера (если я правильно понял)

12. Команда должна регулярно анализировать реализуемые процессы: что получилось, как они этого добились, и постоянно улучшать организацию работы

Часто используемые практики в AGILE: 
1. Совещание = **стендап** //обычно проводится ежедневно по 15-20 минут
  * можно писать отчет о проделанной за день работе, но это уже не AGILE, потому что возникает поток малозначителной документации и меньше взаимодействие в команде

2. Планирование итерации (команда планирует объем работ на планируемую итерацию) //Sprint review meeting

3. UNIT-тестирование. Проверка на корректность отдельных единиц исходного кода, проверка на интеграцию с продакшном
// тоже в рамках sprint review meeting

4. Планирование релизов. Планирование того, что и когда будем выпускать в свет (сначала заказчику - потом на рынок)

**Плюсы Agile:**
● ПО готово к использованию на самых ранних этапах его разработки, пусть и не с полной функциональностью
● Разработчики постоянно в контакте с заказчиком
● Нет жестких рамок = ПО постоянно изменяется и улучшается
● Заказчик и пользователь партнёры и идейные вдохновители
● Нет заранее и подробно сформулированного ТЗ = разработчик может решить задачу творчески

**Минусы Agile:**
● Не факт, что продукт когда-то будет допилен и будет найдена та крайняя итерация
● Пользователь требует все и сразу
● Работа над проектом требует не только профессионализма разработчика, но и сознательности пользователя
● «Золотые пользователи» //случай, когда заказчиков несколько, и степерь их вовлеченности разная, в таком случае некоторые из них могут свои интересы в продукте поднимать на более высокий приоритет, относительно других заказчиков
● Строительство без чертежей
● Постоянная спешка

**Оценка успешности проекта:**
Waterfall и подобные - уложиться в железный треугольник (сроки, бюджет, соответствие ТЗ (по качеству и содержанию))
Agile - чем выше ценность для заказчика, тем успешнее наш проект

