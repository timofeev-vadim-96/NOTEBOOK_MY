

`Потоки-демоны (Daemon Threads)`:

Это потоки, которые обслуживают пользовательские потоки. Если все пользовательские потоки завершают выполнение, потоки-демоны автоматически завершают свою работу, даже если они еще не завершили выполнение своей работы. Потоки-демоны создаются путем вызова метода setDaemon(true) на объекте потока перед его запуском.

---

`В чем отличие между Runnable и Callable?`

Оба интерфейса Callable и Runnable в Java предназначены для выполнения кода в отдельном потоке, но они имеют несколько ключевых различий.

Возвращаемое Значение:

Runnable: Метод run() интерфейса Runnable не возвращает никакого значения. Это означает, что код, выполняемый в run(), не может возвращать результат своей работы.

Callable: Метод call() интерфейса Callable возвращает значение. Поскольку метод call() может возвращать результат, он предоставляет более гибкий способ получения значения из выполненной задачи.

Обработка Исключений:

Runnable: Метод run() не может бросать проверяемые исключения, поэтому все исключения должны быть обработаны внутри самой задачи.

Callable: Метод call() может бросать проверяемые исключения, что позволяет более гибко обрабатывать исключения внутри задачи.

Интеграция с ExecutorService:

Runnable: Может использоваться с ExecutorService для выполнения задач в отдельных потоках, но не может возвращать результаты или обрабатывать исключения также удобно, как Callable.

Callable: Интерфейс Callable предназначен для работы с ExecutorService, и он часто используется с методом submit() этого сервиса, который возвращает объект Future, позволяя получить результат выполнения задачи и обработать исключения.

---

`В чем различие между методами stop и interupt?`

Оба метода, stop() и interrupt(), связаны с управлением потоками в Java, но они выполняют разные функции.

stop():

Метод stop() устарел и не рекомендуется к использованию. Этот метод прерывает выполнение потока, вызывая исключение ThreadDeath.

Использование stop() может привести к непредсказуемым и нежелательным последствиям, таким как несогласованное состояние данных, потеря ресурсов и т. д. Этот метод был помечен как устаревший из-за его потенциально опасного воздействия на программу.

interrupt():

Метод interrupt() служит для отправки сигнала прерывания потоку. Это не непосредственное завершение потока, а скорее уведомление о том, что потоку было предложено прекратить свою работу.

Когда вызывается interrupt(), флаг прерывания устанавливается для соответствующего потока. Однако сам поток решает, как на это реагировать. Например, если поток находится в блокированном состоянии (в ожидании ввода/вывода), вызов interrupt() может вызвать исключение InterruptedException.

---

`В чем различие между методами run и start в классе Thread?`
run():

Вызывает метод run() напрямую, выполняя код в текущем потоке, из которого был вызван.

Не создает новый поток выполнения, а просто выполняет код в текущем потоке.

start():

Запускает новый поток выполнения и вызывает метод run() в этом новом потоке.

Создает отдельный поток выполнения, позволяя параллельно выполнять код в новом потоке.

Монитор - это объект, по которому происходит блокировка во время выполнения синхронизированного участка кода. 

---

https://www.baeldung.com/java-concurrent-locks

`ReentrantLock` — класс из пакета java.util.concurrent.locks, который реализует интерфейс Lock. Используется для управления доступом к общему ресурсу. 1

Особенности класса:

позволяет одному и тому же потоку вызывать метод lock, даже если он его вызывал ранее, без освобождения блокировки; 2
предлагает более высокую эффективность функционирования в условиях жёсткой состязательности: когда несколько потоков пытаются получить доступ к совместно используемому ресурсу, виртуальной машине JVM потребуется меньше времени на установление очередности потоков и больше времени на её выполнение. 4
У класса ReentrantLock, кроме методов интерфейса Lock, есть фабричный метод newCondition(). Этот метод возвращает объект Condition, который позволяет добавить текущий поток в wait set данного объекта Condition. 

---

`Атомарные типы`

**Использование CAS** (Compare-And-Swap):

Атомарные операции обычно реализованы с использованием атомарной инструкции CAS. CAS позволяет атомарно проверять значение переменной и обновлять его, если условие выполнено.

**Предотвращение состояний гонки**:

Атомарные операции предотвращают состояния гонки, когда несколько потоков пытаются одновременно изменить одну и ту же переменную.

**Атомарные классы для объектов**:

Атомарные классы, такие как AtomicReference или AtomicStampedReference, предоставляют атомарные операции для работы с объектами, включая условия для обновления.

В Java в пакете `java.util.concurrent.atomic` предоставляются различные атомарные классы для обеспечения безопасной работы с разделяемыми переменными в многопоточных приложениях.

- AtomicBoolean: Предоставляет атомарные операции для булевых переменных.

- AtomicInteger, AtomicLong: Предоставляют атомарные операции для целочисленных и длинных переменных соответственно.

- AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray:

Предоставляют атомарные операции для массивов соответствующих примитивных типов. AtomicReference: Предоставляет атомарные операции для ссылок на объекты.

- AtomicStampedReference: Предоставляет атомарные операции для объектных ссылок с меткой времени.

- AtomicMarkableReference: Предоставляет атомарные операции для объектных ссылок с булевой меткой.

- DoubleAccumulator, DoubleAdder, LongAccumulator, LongAdder:

Предоставляют атомарные операции для выполнения арифметических операций над значениями типа double и long.

- AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater<T, V>:

Позволяют создавать атомарные операции для обновления поля в экземпляре класса с использованием рефлексии.

---

Что такое `EXECUTOR SERVICES`?
ExecutorService является интерфейсом в Java, предоставляющим удобные методы для управления выполнением задач в многопоточной среде. Вместо явного управления потоками, вы можете представить задачи в виде объектов Runnable или Callable и передать их ExecutorService для выполнения.

`Основные реализации ExecutorService`:

- Executors.newFixedThreadPool(int nThreads):

Создает пул потоков фиксированного размера, в котором количество потоков равно nThreads. Количество потоков постоянно, и они могут выполнять множество задач параллельно.

- Executors.newCachedThreadPool():

Создает пул потоков, который автоматически регулирует размер в соответствии с потребностью в выполнении задач. Новые потоки создаются при необходимости, а неиспользуемые потоки удаляются.

- Executors.newSingleThreadExecutor():

Создает пул из одного потока. Задачи выполняются последовательно в единственном потоке.

- Executors.newScheduledThreadPool(int corePoolSize):

Создает пул потоков, предназначенных для выполнения отложенных и периодических задач. Поддерживает планирование выполнения задач в будущем.

Важные `методы ExecutorService`:
- submit(Runnable task):

Представляет задачу в виде объекта Runnable для выполнения и возвращает Future, через который можно получить результат выполнения или проверить статус выполнения.

- submit(Callable task):

Представляет задачу в виде объекта Callable для выполнения и возвращает Future, через который можно получить результат выполнения или проверить статус выполнения.

- invokeAll(Collection<? extends Callable> tasks):

Подает коллекцию задач Callable и возвращает список объектов Future, представляющих результаты выполнения каждой задачи.

- invokeAny(Collection<? extends Callable> tasks):

Подает коллекцию задач Callable и возвращает результат первой завершившейся задачи. В случае успешного завершения возвращается результат, а в случае ошибки выбрасывается исключение.

- shutdown():

Завершает работу ExecutorService после завершения выполнения всех представленных задач. Новые задачи не принимаются.

- shutdownNow():

Попытка завершения работы ExecutorService немедленно. Возвращает список невыполненных задач.

---

`Какие вы знаете и использовали синхронизаторы?`

- synchronized блоки и методы:

Использование ключевого слова synchronized позволяет создавать критические секции, в которых только один поток может выполнять код. Применяется для обеспечения атомарности операций и избежания состояний гонки.

- ReentrantLock:

ReentrantLock предоставляет гибкую и более мощную альтернативу synchronized блокам. Он позволяет использовать условия (Condition) для управления потоками. Применяется для более точного управления блокировками, например, для попыток снять блокировку с тайм-аутом, или для использования нескольких условий.

- Semaphore:

Semaphore представляет собой счетчик, который управляет доступом к разделяемому ресурсу. Он определяет, сколько потоков могут одновременно получить доступ к ресурсу. Применяется для ограничения количества потоков, которые могут выполнять некоторый код.

- CountDownLatch:

CountDownLatch позволяет одному или нескольким потокам ждать, пока другие потоки завершат выполнение. Применяется, например, для ожидания завершения нескольких параллельных задач перед продолжением выполнения главного потока.

- CyclicBarrier:

CyclicBarrier представляет собой барьер, который блокирует потоки до тех пор, пока не соберется заданное количество потоков. Когда это произойдет, все потоки разблокируются и продолжают выполнение. Применяется, например, для синхронизации задач, которые должны выполняться параллельно и дожидаться друг друга для совместного продолжения.

- Phaser:

Phaser предоставляет более сложный и гибкий механизм синхронизации, чем CountDownLatch и CyclicBarrier. Применяется, например, для согласованной смены фаз выполнения нескольких потоков.

Exchanger:

Exchanger позволяет двум потокам обменяться данными в определенной точке выполнения. Применяется, когда два потока должны обменяться каким-то состоянием или данными.

ReadWriteLock:

ReadWriteLock предоставляет более гибкую блокировку для чтения и записи. Применяется, когда требуется поддержка параллельного чтения, но блокировка для записи должна быть эксклюзивной.