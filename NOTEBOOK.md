# Общая теория
**Языки программиования по количеству** "посредников" между человеком и компилятором делится на 2 типа:
* Интерпретаторы - выводятся построчно (пример - Python)
* Компилляторы - выводится сразу весь код (пример - Java)   

**Ошибки** компилляции бывают 3 типов:  
1. Синтаксические ошибки (неправильно написанные команды, пропущенные знаки, несоблюнеие отступов)
2. Ошибки выполнения (деление на 0)
3. Логические ошибки (программа работает, но не правильно - логика построена не верно)  

Стили оформления кода:  
* Shake_case (от слова snake - змея) (Python)
* CamelCase (от слова camel - верблюд) (C#)

**Массивы** - структура данных, хранящая набор значений (элементов массива), идентифицируемых по индексу или набору индексов  
// пример: гардероб в театре - содержит определенное количество вешалок с определенными номерами. На каждый крючок можно повесить только один элемент одежды (однотипные объекты) 

**Кортеж** (tuple) - частный случай массива или списка, в который нельзя вносить изменения. Значения кортежа пишутся в круглых скобках () . Кортеж занимает меньше памяти и работает быстрее  
(пароли, название хоста)

**Список** - это упорядоченный конечный набор элементов. По сути список - это тот же самый массив, в котором
можно хранить элементы любых типов данных.  

>**Отличие списков от массивов** заключается в том, что список - это динамическая структура, размер которого можно изменять во время выполнения программы (удалять, добавлять элементы)

*Параметры массива:*  
1. Начало массива (адрес первой ячейки с элементами массива)
2. Размер каждого элемента (сколько ячеек памяти занимает каждый элемент массива)
3. Количество элементов в массиве  

**Цикл** - действие, которое выводится множество раз
* while
* for
* foreach

**Фреймворк** - программное обеспечение, облегчающее разработку и объединение разных компонентов большого программного проекта (пример: .NET (для C#), React (для Java), Django (для Python))  

Состав:  
1. Постоянная часть — каркас, не меняющийся от конфигурации к конфигурации  
2. Сменные модули (или точки **расширения**)  

**Правила написания кода**  
1. Код **читается чаще**, чем пишется, не нужно экономить на понятности и чистоте кода ради скорости  
2. Стараться **не использовать** сокращения, кроме общепринятых в разрабатываемом продукте  
3. Не **использовать имена**, потенциально или явно **конфликтующие со стандартными идентификаторами**  
4. Стараться вовсе **не использовать сокращения**  
5. Не использовать **нецензурные слова**  
6. Не использовать **акронимы**  
Пример: ~~SendPM~~ -> SendPrivateMessage  
7. Использовать общие, не привязанные к контексту, имена  
Пример: string ~~str~~ -> string value
8. В С# **имена методов** пишутся **с большой буквы**  
Пример: void Method()  
9. **Избегать длинных строк**, не более 150 символов  
10. Если метод **асинхронный** - он заканчивается на "**Async**"  
Пример: GetStream Async()  
11. Использовать **var**, когда **тип данных не известен** заранее  
12. **Объявлять переменные** непосредственно перед их использованием  
13. **Имена счетчиков**: i, j, k, l, m, n, ...  
14. **Инициализировать переменные** при их объявлении (по возможности)  
15. **Компановать в коде** методы отдельно, свойства отдельно и т.д.  
16. **Комментировать** самые важные части кода, например - **методы**  
17. Использовать **словари** eng/рус  
18. Все константы пишутся большими буквами, CONST = 3,14

**Принципы написания кода**  
* **DRY** - don't repeat yourself - не заниматься копипастом своего кода, думать об автоматизации и переиспользовании  
* **YAGNI** - you aren't gonna next it - вам это не понадобится, не создавать избыточную функциональность  
* **KISS** - keep it simple, stupid - принцип, запрещающий использование более сложных средств, чем необходимо. Принцип декларирует простоту системы в качестве основной цели и/или ценности  

**Легаси (Legacy)** - код, который явно следует переписать, он старый, но очень сложный и работает

> Bit O Notation - время работы алгоритма по верхнему значению 

**Сложность алгоритма** - количество действий, которое необходимо выполнить для получения ответа. Пишется О (n), где n - количество элементов в массиве. 

Нотация O большое говорит о том, чтобы найти такую функцию, которая начиная с какого-то конкретного числа n всегда будет больше нашего значения. 

> Сортировки:  

1. **Сортировка выбором** - суть в том, чтобы запомнить позицию минимального лемента и менять i-й массива с минимальным. Если i-й элемент является min, то он меняется **сам с собой**  

Сложность = n². Память = O (n + 1) // 1 - для temp

2. **Пузырьковая сортировка** - суть в **попарном сравнении** пар элементов и перемещении их в случае необходимости, в итоге крайние элементы массива будут **максимальными.**  

Сложность классической = n², модифицированной = n²/2. Память = O(n)

3. **Быстрая сортировка:**  
  * выбираем из массива элемент, называемый опорным
  * сравниваем все остальные элементы с опорным и переставляем их в массиве так, чтобы разбить массив на 3 части:  
    а) элементы меньше опорного
    б) равные
    в) больше опорного  
  * если длина отрезка (а, б, в) > 1 - повторить  

Сложность = N*logN. Память = O(n) 

4. **Сортировка подсчетом** // только с числами  - целесообразно, когда сортируемые числа имеют достаточно малый диапазон значений по сранвнию с сортируемым множеством, например 1.000 уникальных значений из 1.000.0000  

Суть: Индекс = число // i = 12, значит, что эта ячейка хранит кол-во цифр 12 в массиве. Подсчет идет путем проходки по основному массиву, запись происходит в вспомогательный массив размером abs(min)+max+1

Для отрицательных чисел - учитывать в размере вспомогательного массива, при сравнении числа с индексом учитывать минимальное значение, а именно:  
arr[i] = j - Abs(min)  

Сложность = O(n+k), k - количество уникальных элементов. Память = O (n+k)  

5. **Сортировка слиянием** 

## ООП - ОБЪЕКТНО-ОРИНЕТИРОВАННОЕ ПРОГРАММИРОВАНИЕ 
**ООП** - подход к написанию программного обеспечения  
Принципиально, ООП состоит из:  
1. Описание объекта
2. Описание его поведения

**Принципы ООП** - это как перенос реального объекта в виртуальный мир. Например: описание котика кодом :) + сделать так, чтобы этот котик мог взаимодействовать с другими объектами (его поведение)  

**Суть ООП** - представить программу в виде объектов, которые каким-то образом взаимодействуют друг с другом  

## Файлы
Файлы в текстовом формате используются для: 
 
● Хранения данных  
● Передачи данных в клиент-серверных проектах  
● Хранения конфигов  
● Логирования действий  
Что нужно для работы с файлами:  

1. Завести переменную, которая будет связана с этим текстовым файлом.  
2. Указать путь к файлу.  
3. Указать, в каком режиме мы будем работать с файлом.  

**Варианты режима (мод):**  
* a – открытие для добавления данных.  **(дозаписывает данные)**
  * Позволяет дописывать что-то в имеющийся файл.  
  * Если вы попробуете дописать что-то в несуществующий файл, то файл будет создан и в него начнется запись.  
* r – открытие для чтения данных.  
  * Позволяет читать данные из файла.  
  * Если вы попробуете считать данные из файла, которого не существует, программа выдаст ошибку.  
* w – открытие для записи данных.  **(перезаписывает данные)**
  * Позволяет записывать данные и создавать файл, если его не существует  

Пример кода для работы в 3 режимах с файлами: 
[work_with_files.py](./work_with_files.py)  

**Миксованные режимы:**
1. w+  
   * Позволяет открывать файл для записи и читать из него.
   * Если файла не существует, он будет создан.
2. r+  
   * Позволяет открывать файл для чтения и дописывать в него.
   * Если файла не существует, программа выдаст ошибку.  

**Модуль os для работы с операционной системой**

* os.chdir(path) - смена текущей директории.   
* os.getcwd() - текущая рабочая директория  
* os.path - является вложенным модулем в модуль os и реализует некоторые полезные функции для работы с путями, такие как:  
   * os.path.basename(path) - базовое имя пути (имя файла)
   * os.path.abspath(path) - возвращает нормализованный абсолютный путь (полный путь к файлу) 

**Модуль shutil для того, чтобы копировать, перемещать и удалять файлы и папки**  
* shutil.copyfile(src, dst) - копирует содержимое (но не метаданные) файла src в файл dst.  
* shutil.copy(src, dst) - копирует содержимое файла src в файл или папку dst.  
* shutil.rmtree(path) - Удаляет текущую директорию и все поддиректории; path должен указывать на директорию, а не на символическую ссылку  

> API - Это возможности, которые предоставляют разработчики языка для удобного взаимодействия с его функционалом  
- это описание методов для работы со сторонним сервисом.  

> Чтобы просмотреть API в Int IDEA - Ctrl + левая кнопка мыши на тип класса. 

**Логирование**  
Логи содержат системную информацию работы программного или аппаратного комплекса.  
В них записываются действия разного приоритета от пользователя, или программного продукта.  
Процесс ведения логов называют “логированием” (журналированием).  

Логирование. Использование.  
Использование  
Logger logger = Logger.getLogger()  //внутри гетлоггера указывается тип класса, для кот. будет осуществляться логирование  
Уровни важности  
INFO, DEBUG, ERROR, WARNING и др.  

**Уровень логирования	Описание**  
ALL	Все сообщения  
TRACE	Сообщение для более точной отладки  
DEBUG	Дебаг-сообщение, для отладки  
INFO	Обычное сообщение  
WARN	Предупреждение, не фатально, но что-то не идеально  
ERROR	Ошибка  
FATAL	Фатальная ошибка, дело совсем плохо  
OFF	Без сообщения  

Вывод  
ConsoleHandler info = new ConsoleHandler();  //выводится в консоль  
FileHandler info = new FileHandler("log.xml"); // вывод в файл  
log.addHandler(info);  
Формат вывода: структурированный, абы как*  
XMLFormatter, SimpleFormatter  

**Хэш код** - это адрес на ячейку в памяти, где хранится то или ионое значение.  

--> Конец теории

---

## Google Collab 
> облачный сервис от Google, предназначенный для программистов, которые работают на языке Python. Блокноты Google Colab позволяют объединить в одном документе исполняемый код и форматированный текст.

> **Pandas** - интрумент для работы с табличными данными  
Библиотека pandas может читать многие форматы, включая: .csv, .xslx, .xls, .txt, sql и многие другие. Полный список по [ссылке](https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html "pandas-docs")  

> крутая читалка по работе с Pandas [Pandas](./pandas_for_google_colab.ipynb) - нужно подгрузить из гугл коллаба как блокнот  

Визуализация табличных данных происходит с помощью 2 библиотек:  
- matplotlib  
- seaborn  

DataFrame - это таблица с данными, которая предварительно была
открыта.  

**Логические операторы:**   
& - и. Выполняются все условия  
| - или. Выполняется одно условие  
p.s. - если пишим 2 и более условия - каждое условие в скобках

**Функции библиотеки Pandas:**   

* pd.read_csv('sample_data/file_name.csv') - для чтения  
* .head(10) # элементы таблицы с начала. по умолчанию функция head хранит первые 5 строку, но можно указать больше  
* .tail(2) # элементы таблицы с конца  
* new_data.shape # количество строк и столбцов   
* .isnull() - #проверка на истинность утверждения, что значение ячейки = null. Если ячейка не пустая - 'False' 
  * Чтобы проверить есть ли пустые ячейки:  
  new_data.isnull().sum()  
* .dtypes - для вывода типа данных столбцов    
* .columns # возвращает список с названиями всех столбцов  
* arg[['latitude', 'population']] - вывести определенные столбцы  
* new_data[new_data['housing_median_age']<20] - делаем выборку. список внутри возвращает список со значениями bool - true, false. в итоге выводится new_data от тех значений, которые явл. true  
* new_data[(new_data['housing_median_age']<20) & (new_data['housing_median_age']>10)]['total_rooms'] - вывести 1 столбец с условиями
* print(new_data['population'].max()) - вывести макс/мин значение столбца  
  * .mean() - среднее значение  
  * .sum() - сумма всех значений столбца  
  * .median() - медианное значение. Сортируем список и значение, которое будет ровно посередине и есть медианное.  
  Пример: 1,50,40,1,2,56,1,25,1. Медиана - 2. Т.к. 
  1,1,1,1,**2**,25,40,50,56 - она ровно посередине.   
  * new_data.describe() - выводит всю информацию о таблице, где:  
  count - Общее кол-во не пустых строк, mean - среднее значение в столбце
std - стандартное отклонение от среднего значения,  
min - минимальное значение,  
max - максимальное значение  
Числа 25%, 50%, 75% - перцентили  
**Перцентиль** - это показатель, используемый в статистике, показывающий значение, ниже которого падает
определенный процент наблюдений в группе наблюдений  
* .loc - метод, который принимает метки индекса и возвращает строку или DataFrame, если метка индекса существует в вызывающем DataFrame. Входные данные могут быть различных типов. Одна метка, например, 9 или «x», или любое другое одиночное значение может быть любого типа. Это может быть список или массив меток. Ex – [‘a’,’b’,’c’,’d’], и это также может быть логический массив. Ex- [False, True, False].  
* Pandas dataframe.corr() используется для нахождения попарной корреляции всех столбцов в фрейме данных Pandas в Python. Любые значения NaN автоматически исключаются. Любой нечисловой тип данных или столбцы в Dataframe игнорируются.  
Пример:  
corr = df.corr()  


**метод loc в [], первый аргумент индекс или селектор, а второй список со столбцами**

Пример:  
new_data.loc[:, ['population', 'households']] - выведет все значения двух колонок  
- c условием:  
new_data.loc[new_data['population'] < 500, 'population'] 
- с условием вывести 2 столбца:  
c_test.loc[c_test['median_income']< 2, ['median_house_value', 'median_income']]  
- c 2 условиями - каждое условие брать в скобки:  
c_test.loc[(c_test['housing_median_age']< 20) & (c_test['median_house_value']>70000)]  
  * создать новый столбец с помощью loc:  
  new_data.loc[new_data['housing_median_age'] <= 20, 'age_group'] = 'Молодые', где age_gropu - новый столбец. И если возраст 20 и менее - то значение столбца будет 'молодые'  
* .groupby - чтобы скомпановать по значениям какого-то столбца  
Пример: 

* Пример использования фиктивной переменной: в вид  one hot с помощью get dummies:  
import random  
import pandas as pd  
lst = ['robot'] * 10  
lst += ['human'] * 10  
random.shuffle(lst)  
data = pd.DataFrame({'whoAmI':lst})  
data.head(20)  
# data.shape  
> pd.get_dummies(data, columns=['whoAmI'], drop_first= True ) 


> **Scatterplot (Точечный график)**
Математическая диаграмма, изображающая значения двух переменных в виде точек на декартовой плоскости.
**Библиотека seaborn** без труда принимает pandas DataFrame(таблицу). Чтобы изобразить отношения между
двумя столбцами достаточно указать, какой столбец отобразить по оси x, а какой по оси y.  
- не забыть **импортировать**: import seaborn  
**Функции библиотеки Seaborn:**  
* **scatterplot** - seaborn.scatterplot(data = new_data, x = 'название столбца', y = 'название столбца', hue = 'оттенок, может задаваться также столбцом, значение данных будет выражаться оттенком', size = 'размер маркеров на графике, тоже можно задавать столбцами') 
* **PairGrid** - показывает все возможные отношения между выбранными столбцами таблицы, либо всеми столбцами.  
Пример:  
сolumns = ['population', 'households', 'total_rooms'] # задаем какие столбцы нам будут нужны из сходной таблицы  
graphic = sb.PairGrid(new_data[сolumns]) # определяем тип отношения  
graphic.map(sb.scatterplot)  # определяем в виде какого графика будем выводить  
* **relplot** - хороший вариант для визуализации значений, зависящих от временной переменной. Принимает DataFrame, x, y - столбцы.  
Пример:  
sb.relplot(x = 'latitude', y = 'median_house_value', kind = 'line', data = new_data), где - kind - тип отображение, а данном случае линия  
* **histplot** - построить гистрограмму. Гистограмма
Способ представления табличных данных в графическом виде — в виде столбчатой диаграммы. По оси x обычно
указывают значение, а по оси y - встречаемость(кол-во таких значений в выборке).  
Пример:  
sb.histplot(data = new_data, x = 'median_house_value') # получаем отношение средней цены дома к количеству домов с такой ценой  
* **plot** - построить гистограмму раздельными столбиками  
Пример:  
.plot(kind='bar'), где bar - столбец. один из типов  

**Библиотека numpy - для вычислений линейной алгебры** - используем при вычислениях для тепловой карты. 

**Matplotlib** — библиотека на языке программирования Python для визуализации данных двумерной и трёхмерной графикой. Получаемые изображения могут быть использованы в качестве иллюстраций в публикациях

* **matplotlib.pyplot** представляет собой набор функций, которые заставляют matplotlib работать как MATLAB. Каждая pyplotфункция вносит некоторые изменения в фигуру: например, создает фигуру, создает область построения на фигуре, строит несколько линий в области построения, украшает график метками и т.д.  

**Состав**:  

* Figure - это контейнер самого верхнего уровня, та область на которой все нарисовано. Таких областей может быть несколько, каждая из которых может содержать несколько контейнеров Axes.

* Axes - это та область на которой чаще всего и отражаются графики (данные в виде графиков), а так же все вспомогательные атрибуты (линии сетки, метки, указатели и т.д.). Часто, установка этой области сопровождается с вызовом subplot, который и помещает Axes на регулярную сетку. Поэтому, так же часто Axes и Subplot можно считать синонимами. Но с тем что это за сетка и как это размещение работает, давайте разберемся чуть ниже.

*Каждая область Axes содержит XAxis и YAxis. Они содержат, деления, метки и прочие вспомогательные атрибуты.* 

import matplotlib.pyplot as plt

* pyplot.subplots создает фигуру и сетку вложенных графиков с помощью одного вызова

  * Создаем полотно для отображения большого графика  
f, ax = plt.subplots(figsize=(11, 9))  

  * Создаем цветовую политру  
cmap = sns.diverging_palette(230, 20, as_cmap=True)

Пример кода:  

fig = plt.figure () # мы создали область Figure, экземпляр класса figure  
ax = fig.add_subplot(222) # мы разместили на figure - subplot/axes, 111 - это первая строка, первый столбец и первая (единственная) ячейка на сетке Figure.  
fig.set_facecolor('green') # меняем цвет + отлично видно разницу между figure and axes  
ax.set_facecolor('blue')  
ax.set_xlim([-10, 10])  
ax.set_ylim([-2, 2])  
ax.set_title('Основы анатомии matplotlib')  
ax.set_xlabel('ось абцис (XAxis)') # именование оси х  
ax.set_ylabel('ось ординат (YAxis)') # по аналогии  
plt.show()  

# Кстати, Axes должна принадлежать только одной области Figure. Как правило, всегда сначала создается область Figure, а затем с помощью add_subplot() 
# в Figure размещается одна или несколько областей Axes.

**Типы kind:**  
* area - для графиков с накоплением;
* bar - для вертикальной гистограммы;
* barh - для горизонтальной гистограммы;
* box - для графиков с боксами;
* hexbin - для шестнадцатеричных графиков;
* hist - для гистограмм;
* kde - для графика оценки плотности ядра;
* density - является альтернативным названием для kde;
* line - для линейных графиков;
* pie - для круговых графиков;
* scatter - для графиков рассеяния.  






---

## Базы данных  

**СУБД** - система управления базами данных  

**База данных** - предн. для хранения, обработки и быстрого извлечения необходимой информации  

**Реляционные базы данных** (relations - отношения) - базы данных, в которых данные распределены по отдельным, связанным между собой, таблицам

id - уникальный идентификатор (для первичной таблицы - **первичный ключ**, для остальных - **внешний ключ**)  

**Создание структуры базы данных:**

"Поле", "Тип", "Длина(размер)", "Комментарий"

  * Тип: 
    * Date  
    * Int  
    * Text  
    * Time  
    * TimeStamp - отсечка уникального момента во времени  
    * Real - как float, только автомат. определяет кол-во значений после запятой  

**Правила создания баз данных** от Камянецкого:  
1. Чем больше атрибутов - тем лучше
2. Всегда иметь идентификатор
3. Если кажется, что индентификатор не пригодится, читай п. 2  
4. DRY - don't repeat yourself - если хочешь что-то скопировать, то, скорее всего, нужно создавать новую таблицу
5. Не лишним будет выработать свой стиль (имена могут быть зарезервированы, если они простые, очевидные)  
6. Визуализировать: лучше 1 раз увидеть, чем 100 раз услышать
7. У одной системы может быть несколько БД, у нескольких систем не может быть одна БД (чтобы из-за одной БД не легли все системы)
8. Иметь tag - системное поле на всякий случай  
9. Select*From table_name - лучше так не делать, чтобы не вытянуть всю инфу вместе с ненужной после ее редактирования

Некотороые ячейки необходимо **разбивать**, например:  

**Телефон:**
  * +7/+44 - страна  
  * (985) - оператор  
  * 123 45 67 - абоненский тел. номер  

**Адрес:**  
  * страна  
  * субъект  
  * город  
  * улица
  * дом
  * строение
  * корпус
  * квартира / помещение  

**ФИО**  
  * Фамилия
  * Имя
  * Отчество  

**Типовые размеры полей:**  
1. Дата рождения - 8
2. Телефон - 16
3. id - 10
4. Комментарий - 100
5. Имя/фамилия/отчество - по 30
6. Паспорт_серия - 10
7. Паспорт_номер - 20
8. Гос. номер авто - 16
9. TimeStamp - 12

**Типы связей в таблице:**  
* 1 к 1: ребенок - мать  
* 1 ко многим: мать - 1 и более ребенок 
* многие ко многим:  1 человек - несклько адресов, 1 адрес - несколько людей   

**Коллекции данных:**   
* Список  
* Словарь  
* Множество 

**Словари** — неупорядоченные коллекции произвольных объектов с доступом по ключу. В списках в качестве ключа используется индекс элемента. В словаре для определения элемента используется значение ключа (строка, число).  
! Словарь может содержать разные типы данных (int, string, массивы, списки, словари и т.д.) 

**Множество** -  содержит в себе **уникальные элементы**, **не упорядоченные**. Одно множество может содержать значения любых типов. НЕЛЬЗЯ добавитьв множество элемент, который в нем уже содержится.  

**Функция** — это фрагмент программы, используемый многократно.

**Генетический алгоритм** — это в первую очередь эволюционный алгоритм, другими словами, основная фишка алгоритма — скрещивание (комбинирование). Так вот, путем перебора и самое главное отбора получается правильная «комбинация».   

**Алгоритм:**  
1. Задание функции приспособленности -> 
2. Создание начальной популяции ->   
3. Отбор (селекция) -> 
4. Скрещивание ->   
5. Мутация -> 
6. Формирование нового поколения -> 
  * Если результат не достигнут -> повтор с п.2  

**Преимущество** гететического алгоритма - **адаптация** к изменяющейся окружающей среде. При использовании традиционных методов все вычисления приходится начинать заново, а при эволюционном подходе популяцию можно анализировать, дополнять и видоизменять применительно к изменяющимся условиям (**я так понимаю - при изменении функции приспособленности**)

**Алгоритм** - это набор инструкций для выполнения некоторой задачи.  

**EDA(Exploratory Data Analysis)** - Разведочный анализ данных.
Он состоит в анализе основных свойств данных, нахождения в них
общих закономерностей, распределений и аномалий, построение
начальных моделей, зачастую с использованием инструментов
визуализации.  
Цели:  
1. Максимальное «проникновение» в данные
2. Выявление основных структур
3. Выбор наиболее важных переменных
4. Обнаружение отклонений и аномалий
5. Проверка основных гипотез  


----->> КОНЕЦ ОБЩЕЙ ТЕОРИИ

---

# SQL  

* Извлечение данных из таблицы:  
Примеры:
  * **из одной таблицы:**  
    Select * From - Общий список, где:  
    * Общий список - название таблицы  
    * Select - указываем набор столбцов  
    * "*" - означает, что мы хотим видеть все столбцы  
    * From - откуда необходимо выбрать информацию    

  * *Если не все столбцы:  *
    * Select Фамилия, Тел., Комментарий  
    * From Общий список  
    * Where статус = "холост" // в SQL знак " = " - это сравнение  

  *  **из нескольких таблиц:**  
    Select * From peoples;  
    Select * From addresses;  
    Select * From peoples LeftJoin addresses ON peoples.identifier = addresses.Whose_addresses;  

  *  *Если необходимо выбрать таблицы по столбикам:*  
    Select  
      peoples.full_name,  
      peoples.status,  
      telephones.phone_number  
    From peoples LeftJoin telephones ON peoples.identifier = telephones.whose_phone  

> Команды SQL  

like - содержит в себе  
Пример: select * from ученики where характеристика like *'ленив'*;  

Чтобы **обратиться к полю с пробелом**, необх. взять его в квадратные скобки []  
Пример:  Классы.[Номер класса]

>Присоединение таблиц  

* Inner Join - покажет все элементы, где есть соответствие между таблицами
* Left Join - покажет все элементы левой таблицы + элементы правой таблицы, которые соответствуют элементам левой таблицы
* Right Join - покажет все элементы правой таблицы + элементы левой таблицы, которые соответствуют элементам левой таблицы  
* Full Join - покажет все элементы обеих таблиц  

**Пример**: Left Join Люди, адреса on id = чей адрес

---

## Microsoft Access  
Реляционная система управления базами данных (СУБД) корпорации Microsoft.   

**2 режима** работы с таблицей: 1 - заполнение таблицы, 2 - конструктор таблицы  

! Для работы со **схемой базы данных**, необходимо закрыть все таблицы  
  * Работа с базами данных - схема данных

Чтобы **создать запрос**  
* создание - мастер запросов  
* создание - конструктор запросов - SQL  



----->> КОНЕЦ БАЗ ДАННЫХ

---

## Формулы
> Определение расстояния между 2-мя точками в 2D пространстве:  
Дано: A (xa, ya), B (xb, yb)  
AB = √((xb - xa)² + (yb - ya)²)  

> Определение расстояними между 2-мя точками в 3D пространстве:  
Дано: A (xa, ya, za), B (xb, yb, zb)  
AB = √((xb - xa)² + (yb - ya)² + (zb - za)²) 

---

# C#  
**Арифметические операции:**
* i++ (i = i + 1) - инкремент
* i-- (i = i - 1) - дискремент
* // - деление нацело, без остатка, с округлением  
* && - И (должны быть соблюдены оба условия)
* || - ИЛИ (должно быть соблюдено лишь одно условие)  

> Чтобы сделать комментарий к коду - //, временный комментарий - // TODO:

**Типы данных:**
* char - символ  
* string - строка
* int - целое число
* float - дробное число
* double - дробное число, с большим количеством памяти, выделяемых под него
* bool - логические тип  
* var - автоматическое определение типа данных  

**Интерполяция**  - для выведения значения переменных в контексте
// пример: WrileLine($"переменная x = {x}") Ключевой момент - использование знака доллара перед ковычками  

**Конкантенация** - операция склеивания объектов линейной структуры, обычно строк  
// пример:  WrileLine("текст" + arg)  

>> КОМАНДЫ: // (переменная - arg)  

___
----->> НАЧАЛО КОДА **C#**
___

\t - **табуляция** между элементами, к примеру, массива  

\n - **с новой строки** 

Console.WriteLine("Hello, World!"); - **вывод в консоль**

Console.ReadLine(); - **считывание вводимых пользователем данных**

переменная.ToLower - **игнорирует размер букв** (например: "МаШа")

Чтобы **возвести в степень**:  
math.pow(x,y) x - число, y - в какую степень его возвести  

Чтобы получить **квадратный корень:**   
Math.Sqrt(x)  
или * 1/2  

Чтобы **округлить**:  
Math.Round (d, 3), где d - переменная, 3 - количество знаков после запятой

**Чтобы конвертировать в int**  
Convert.ToInt32(arg) / int.Parse(arg) // 32 - в десятичное число  

Чтобы **задать/объявить пустую строковую переменную**:  
string arg = String.Empty; или = "";

Чтобы **создать массив:** 
   * одномерный: int [] arr = new int [size];  
   * вмумерный: int [,] arr = new int [rows,columns];  
   * трехмерный: int [,,] arr = new int [length,width, height];  


Чтобы **вывести массив:**  
  * Для **одномерного** массива:  
    * WriteLine(String.Join(", ", arr)); где ", " - сепаратор, arr - массив
    * for (int i = 0; i < arr.Length; i++)  
{  
    System.Console.Write(arr[i] + "\t");  
    // "t" - табуляция, Write - чтобы в одну строку  
}  
  * Для **двухмерного** массива:
    for (int i = 0; i < rows * columns; i++)  
{  
    if (i%columns == 0) System.Console.WriteLine();   
    // перенос на следующую строку, когда количество итераций будет кратно значению columns  
    System.Console.Write(arr[i / columns, i % columns] + "\t");   
    // "t" - табуляция, Write - печать в одну строку   
}

Чтобы **задать рандомное значение элементу**:  
  * **целое число:**  
  int arg = new Random().Next(1,10); 
  int arg = Random.Shared.Next(left,right);
  * **дробное число:**  
  arg = new Random().NextDouble(); //значения будут в промежутке от 0 до 1, для того, чтобы получить значения > 1, просто умножить на 10 или 100 и т.д.  
  *  **чтобы сократить рандомайзер**:  
  Random rand = new Random();  
  и далее используем переменную -> rand.Next();  
* Чтобы **создать массив из рандомных элементов**:  
int [] arr = new int [N].Select (r => rand.Next(0,5)).ToArray(); // r - объявлять не нужно

Чтобы **заполнить двухмерный массив с помощью одного цикла:**  
for (int i = 0; i < rows * columns; i++)  
{  
    arr[i / columns, i % columns] = new Random().Next(1, 10);   
}  

Чтобы **заполнить массив строк** при вводе с клавиатураы:  
string [] arr = console.ReadLine().Split(" "); // будет заполнять массив при вводе данных через **пробел**  

Чтобы **заменить символ**:  
arg.Replace("что заменить","на что");  

Чтобы создать документацию к методу:  /// 

>**Тернарный оператор**  
**Пример**:  
res += arr[i] > 0 ? arr [i] : 0;  
// arr [i] > 0 (**истина**): res += arr [i];  
// array [i] > 0 (**ложь**): res += 0;  

**MAX и MIN для сравнения чисел:**  
*принцип придания абсурдности*
  * min = int.MaxValue;  
  * max = int.MinValue.  

**Чтобы конвертировать в string**  
arg.ToString();  

Чтобы **сократить логические код**:  
  * На примере "**проверка на четность**"  
  bool IsEven (int value)  
  {  
    return value % 2 = 0; // true/false  
  }  

Чтобы **узнать тип переменной (данных)**:  
Console.WriteLine(arg.GetType().Name);  

Чтобы **вычленить из типа string данные** для дальнейшего использования:  
string text = "(1,2) (3,4) (5,6) (7,8)";  
var data = text.Split(" ").ToArray(); // теперь это массив данных ->   
Результат: string [] data = [(1,2),(3,4),(5,6),(7,8)]  

Чтобы **запустить файл программы:**  

1. **Вручную в папке**: ...\Знакомство с С#\Семинар 3\HW_sem3\bin\Debug\net6.exe  
2. **Из cmd**: cd C:\Users\...\bin\Debug\net6.0  
start file.exe    

Чтобы **засечь время выполнения** куска кода:   

using System.Diagnostic;  
Stopwatch sw = new();  
sw.Start();
...  
sw.Stop();  
Console.WriteLine.ElapsedMilliseconds; // вывод результата в миллисекундах   
sw.Reset(); // обнулить таймер  

Чтобы **не писать Console**....  
using static System.Console;  

Чтобы **не писать String**....  
using static System.String;  

Чтобы **вывести методы красиво:**  
перед типом переменной в () после объявления метода добавить "this"  
**Пример**: int Method (this int [] ...) // нельзя исп-ть с void типом  
**Итог**:  
10.CreateArray().Show().SortSelection().Show(); // 10 - размер массива

Чтобы **прописать исключение**, при котором заканчивается выполнение программы с выводом текста:  
if (...) throw new Exception ("...");

> Чтобы создать поток:  

int eachThreadCalc = N/THREADS_NUMB;//**количество элементов на поток**  
var threadsList = new List<Thread>();// **создаем поток**   
for (int i = 0; i < THREADS_NUMB; i++)  
{  
    int startpos = i*eachThreadCalc;  
    int endpos = (i+1)*eachThreadCalc;  
    if (i == THREADS_NUMB-1) endpos = N; //**для последнего потока остаток значений**  
    threadsList.Add(new Thread(() => ProductOfParallelMatrices(Matrix1,Matrix2, startpos, endpos)));  
    //**каждому потоку распределили что он должен делать** 
    threadsList[i].Start(); //**запускаем поток**  
}  
for (int i = 0; i < THREADS_NUMB; i++)  
{  
    threadsList[i].Join();// **ждем, пока все потоки будут готовы** (посчитают задание)  
}   

Чтобы заблокировать пуск кода для других потоков:  
object = locker = new object();
lock (locker) // locker - команда блокировки   
{  
    code  
}

**namespace** - пространство имен  

Чтобы вывести строку из рандомных элементов, букв, цифр:  

var arg = $"Name{Guid.NewGuid().ToString().Substring(0,5)}" 

Чтобы взять **модуль числа**:  

Abs(number) // не забыть System.Math;  

Чтобы **скопировать массив в другой** массив:  
arr.Copy(arr1, arr2, size);


> Клиент - сервер  

Потоки могут быть:  

1. < Thread > - поток исполнения
2. < Stream > - поток данных

Тип данных для поток записи - StreamWriter (данные с клиента на сервер)  
Тип данных для поток чтения - StreamReader  

Связь TCF - требует постоянное соединение, в случае разрыва - сервер упадет 

>Чтобы **хостить на своем компьютере IP - ip 127.0.0.1**  

Типы запросов: 
- get - получить, read (R)  
- put - обновить, update (U)  
- post - создать, create (C)  
- delite - удалить, delete (D)

___
----->> КОНЕЦ КОДА  **C#**
___

> Работа с директориями  
* Чтобы **получить информацию о папке**:    

string path = "C:/Users/DELL/Desktop/...; - **путь к папке**  
DirectoryInfo di = new DirectoryInfo(path);
Console.WriteLine(di.CreationTime); // **возвращает время создания папки**

void CatalogInfo(string path, string indent = " ")  
{  
DirectoryInfo catalogs = new DirectoryInfo(path);  
foreach (var currentCatalog in catalogs.GetDirectories()) // **возвращает список подпапок**
{  
Console.WriteLine($"{indent}{currentCatalog.Name}");  

CatalogInfo(currentCatalog.FullName, indent + " ");  
}  
foreach (var item in catalogs.GetFiles()) // **возвращает список папок текущей директории**  
{  
Console.WriteLine($"{indent}{item.Name}");  
}  
}    
CatalogInfo(path);  

> МЕТОДЫ 

**4 типа методов:**
1. *Ничего не принимает и ничего не возвращает*  
**Пример:**
void Method1()  
{  
    Console.WriteLine("Text");  
}  
Method1(); - **Чтобы вызвать метод** 
2. *Ничего не принимает, но что-то возвращает*  
**Пример:** 
void Method2(string msg)  
{  
Console.WriteLine(msg);  
}  
Method2(msg: "Текст сообщения"); - метод ничего не принимает, значение переменной msg мы прописываем при его вызове
3. *Ничего не принимает и ничего не возвращает*  
**Пример:**  
int Method3()  
{  
    return DateTime.Now.Year;  
}    
int year = Method3();
Console.WriteLine(year); 
4. Что-то принимает и что-то возвращает  
**Пример:**   
string Method4 (int count, string c)  
{  
    int i = 0;    
    string result = String.Empty; 
    while (i < count)  
    {  
        result = result + c;  
        i++;  
    }   
    return result;  
}  
string res = Method4(10, "qwerty");  
Console.WriteLine(res);

> **РЕКУРСИЯ** - функция, которая вызывает саму себя

У рекурсии 2 случая:  
1. базовый - условие для выхода из рекурсии  
2. рекурсивный - вызов функции самой себя  

**На примере чисел Фибоначчи**

// f(1) = 1  
// f(2) = 1  
// f(n) = f(n-1) + f(n-2)  
double Fibonacci(int n)  
{  
    if (n == 1 || n == 0) return 1;  
    else return Fibonacci(n-1) + Fibonacci(n-2);  
}  
for (int i = 0; i <= 45; i++)  
{  
    System.Console.WriteLine($"{i} = {Fibonacci(i)}");  
}  

**На примере программы для перевода из десятичного кода в бинарный**  

int N = 15;  
void ToBinary (int num)  
{  
    if (num == 0) // выход из рекурсии  
    {  
        return;  
    }  
    ToBinary(num/2);  
    System.Console.Write(num%2);  
}  
ToBinary(N); // - вызов метода  

**На примере Факториала**  
int Factorial (int N)  
{  
    if (N == 1) return 1; // базовый случай  
    return N*Factorial(N-1); //рекурсивный случай  
}

**Пример: Рекурсия**, в которой используются новые переменные:  
[task_47.py](./task_47.py) 


---

# PYTHON  
## Python - язык с динамической типизацией (переменная может быть переопределена в теле кода)  

* **Виртуальное окружение** (virtual environment)  
Чтобы создать -> python3 -m venv .folder  

* Чтобы **запустить python компилляцию**:  
1. Ctrl + F5  
2. python file.py   
3. кнопка в правой части экрана  

**Базовые типы данных Python**  
int  -||-  
float -||-  
bool  -||-   
str  - строка   

**Арифметические операции:**
* i+=1 (i = i + 1) - инкремент
* i-=1 (i = i - 1) - дискремент  
* i*=1 (i = i * 1)  
* i/=1 (i = i / 1) - получится **вещественное значение**
* i//=1 (i = i // 1)  - деление нацело, без остатка, с округлением  
* i%=1 (i = i % 1) - остаток от деления  
**Логические операторы:**
* and - И (должны быть соблюдены оба условия)
* or - ИЛИ (должно быть соблюдено лишь одно условие)  
* not - не (отрицание)  
* elif - else if  
* else - **при использовании после цикла** While - случай, когда основное тело цикла перестает работать самостоятельно (выполнено условие для выхода из цикла)  

>> КОМАНДЫ: // (переменная - arg) 

----->> НАЧАЛО КОДА **PYTHON**  

>**Переменные объявляются** без их типов  
пример:  number = 5  

Чтобы **создать пустую переменную**:  
arg = None  

Чтобы **создать строковую переменную**:  
arg = 'qwerty' or "qwerty"  
> При **переборе строковой переменной** через цикл, i/item - это буква в строке, а не как у массива - list[i] = 'какой-то элемент'

Чтобы сохранить **тип переменной(данных)**:  
type(n)  

Чтобы вывести в "print" ковычки, поставить \ перед знаком  
Пример: 'fd\'fd' = fd'fd  

>**Чтобы комментировать код:**  
\# - для одной строки  
\### - (перед 1 и крайней строкой) многострочный комментарий  
Ctrl + K + Ctrl + C - многострочный комментарий  
CTRL + / - комментировать все, что выделено  

**Чтобы вывести данные:** 
print(f"{a} = arg qwerty"), где f - символ интерполяции  

**Чтобы ввести данные:**   
* input(),   -  ввод будет осуществлен на след. строке
* input('введите сообщение'), - ввод будет осуществлен на той же строке, при этом приветственное сообщение нигде не сохраняется, а лишь является инструкцией для ввода данных. Введенные данные будут иметь **тип string**  

Чтобы привести данные (**приведение типов** данных):  
n = int(c) / b = int(input('text'))  

* привести список в строку:  
data_str = ', '.join(map(str, arr))  

**Цикл for (фор)**  
Пример:  
for in in arr (по всей его длине) / range(5) - от 0 до 4 / range(2,10) - от i=0 to 9 / range(0,10,2) - где 2 - это шаг  
* range выдает значение из диапазона с шагом 1 в базовом случае  
* если указано только одно число (значение переменной), то от 0 до числа (значения переменной)  
* третий аргумент в range **задает шаг**  

Чтобы **использовать длину** массива (переменной):  
len()  

Чтобы **проверить есть ли строка в строке** с логическим ответом:  
print('qwerty' in text), где text - строковая переменная, результат будет true or false  

Чтобы **перевести текст в нижний регистр**:  
print (text.lower())  

Чтобы **перевести текст в верхний регистр**:  
print (text.upper())  

Чтобы **заменить символы в строковой переменной**:  
print (text.replace ('text', 'TEXT'))  

> Индексация - срезы  

**Примеры**:  
text = 'булки'  
text [ 0 ]  = 'б'  
text [ - 1 ] = 'и' - **индексация с конца** со знаком отрицания  
print ( text [ : 2 ] ) = 'бу', т.к. от 0 до < 2  
print ( len ( text ) - 2 : ) = это значит от 2 с конца до конца = 'ки'  
text [ 2 : 9 ] = со 2 по 8  
text [ 0 : len ( text ) : 6 ] = от 0 до len -1 **с шагом** 6  
text [ ::6 ] = от начала до конца **с шагом** 6  

Чтобы **напечатать (вывести) "сырую" строку**, не обращая внимания на пемененные и фигурные скобки:  
print ( r 'qwerty {x} qwerty '), r - raw ( сырая )

Чтобы **импортировать библиотеку PYTHON**:  
import math  - математика
import cmath - сложная математика  
import random - для создания случайных значений  
import cv2 - для работы с Open CV  
import os - для работы с операционной системой (файлами и путями к ним)   
import shutil - для обработки файлов, групп файлов, и папок (копировать, перемещать и удалять файлы и папки)  

Чтобы **округлить**:  
* в большую сторону - math.ceil (2.4 - > 3)  
* в меньшую сторону - math.floor (7.99 - > 7)  
* откинуть дробную часть - math.trune (2.3 - > 2)  

Чтобы **получить правую часть дроби**:  
%1 (6.88 -> 0.88)  

Способоы **задать переменную**:  
* a = b = 1  
* a, b, c = 2

Чтобы **задать массив**:  
arr = [0] * 10 # массв, размером 10, заполненный нулями   

Чтобы **создать кортеж**:  
t = () - пустой кортеж  
t = (1, ) - кортеж со значениями, после нулевой переменной - обязательно **запятая**. Далее - нет необходимости  
* Чтобы перевести массив или спсок в кортеж:  
t = tuple(v), где v - список или массив  
* Чтобы "**распаковать кортеж**" необходимо количество переменных, равных значению кортежа:  
v = (1,2,3)  
a,b,c = v  
print(a,b,c)  =>  1, 2, 3

Чтобы **записать строку в массив**:  
S = input().split()  
A = [ len (s) ] 
A = [ int(i) for i in S ]  

Чтобы **что-то добавить (append) в список (list)**:  
for i in list:  
new_list.append (int(i))  
* Передать более 1 элемента в список:  
res_list.append((i, i*i))  

Чтобы вывести **индекс значения списка**:  
new_list.index(value)

Чтобы **создать список**:  
* list_1 = [] # **Создание пустого** списка
* list_2 = list() # Создание пустого списка
* list_1 = [7, 9, 11, 13, 15, 17]  

**Генератор списка (list comprehension)**  // фишка Python
* обычный способ  
list_1 = []  
for i in range(1, 101):  
list_1.append(i)  
print(list_1) # [1, 2, 3,..., 100]  
* **с помощью генератора**  
list_1 = [i for i in range(1, 101)]# [1, 2, 3,..., 100]  
  * с условием:  
  list_1 = [i for i in range(1, 101) if i % 2 == 0]# [2, 4, 6,..., 100]  
  * пара из чисел с условием:  
  list_1 = [(i, i) for i in range(1, 101) if i % 2 == 0]# [(2, 2), (4, 4),..., (100, 100)]  
  * можно умножать, делить и т.д. итемы i:  
  list_1 = [i * 2 for i in range(10) if i % 2 == 0] # [0, 4, 8, 12, 16]  
  * **генератор двумерного списка**:  
    *  n = 4  
       a = [[0] * n for i in range(n)]  
    * **с условием** (в данном случае - диагональ матрицы)  
    a = [[int(i==j) for i in range(n)] for j in range(n)]  (логика bool)  
      * lst = [[1 if i == j else 0 for j in range(n)] for i in range(n)]  

* **создать список с клавиатуры:**  
A = list (map (int, input ().split())), где map: 1 - тип, например int, 2 - составной тип данных (список)  

Чтобы **вывести список**:  
* print(list_1) - выведится с квадратными скобками  
* print(*list_1) - выведится без скобок, через запятую 
* **вывести двумерный список:**  
print(*a,sep = '\n')  

Чтобы **добавить** в список элемент:  
list_1.append(8) - в конец списка  
list_1.insert(2,11) - цифра 11 добавляется на 2 позицию, при этом все остальные элементы списка смещаются вправо

Чтобы **удалить** элемент списка:  
list.pop() - удаляет последний элемент
list.pop(0) - удаляет конкретный элемент по индексу
Кроме того, pop - возвращает значение,   
пример: a = list.pop()  
print (a) : a = list(-1)

Чтобы **вывести массив**:  
1. for i in range (len (A)):  // выводит массив в 1 строку  
print (A[i], end = " ")  
2. for x in A:  
print (x, end = " ")  
3. print (*A) // * - означает, что необходимо преобразовать массив в набор отдельных значений 

Чтобы добавить случайные (рандомные) значения в список:  
* использовать **random.randint ()**  
**Пример**:   
import random  
ran_list = []  
n = 10  
for i in range (n)  
rand_list.append(random.randint(3,9))  
print(rand_list)  

**Создать список с рандомными значениями в одну строчку:**  
list = [random.randint(0,100) for x in range(n)], где n - размер списка 

* использовать **random.sample ()** // похоже, не работает с отрицательными числами  
**Пример**:  
import random  
res = random.sample(range(1,50), 7) // 7 - размер списка, создает уникальные элементы!  
print("Random number list is: " + str(res))  

* перемешать список:  
  * random.shuffle(x), где х - итерируемый объект. Для строки и кортежа - необходимо сначала перевести в список.

* Чтобы найти **максимальное значение в списке** (итерируемом объекте):  
max_value = max(input_grade_list)  
* Можно испльзовать ключ (key), для перебора списка, в котором ищем макс:
  * max_orbit = max(orbits, key = lambda x: (x[0] != x[1])*x[1]*x[0]), orbits - список, key - условие для списка и КАК мы сравниваем элементы списка. В данном случае х - это кортеж, произведение элементов которого мы будем сравнивать с остальными элементами списка orbits  


> Очереди задач Python  

**принцип FIFO** - first in, first out:  
Данные поступают в очередь с конца, а выходят с головы (все как в обычной очереди к кассе - первый зашел, первый вышел)  

**принцип двусторонней очереди**:  
Войти и выйти можно с обеих сторон  

> **REDIS** - база данных (No SQL) - хранит БД в оперативной памяти, что позволяет обрабатывать большое количество запросов /sec.   
P.s. с обычной базой данных мы можем выполнять лишь, примерно, 150-200 операций /sec.  

p.s. - вся информация на REDIS хранится **в байтах**

Команды для работы с **REDIS**:  
* set name Vadim  // или любая другая переменная со своим значением
* get name  
* Keys * // вывести все значения  
* LRANGE queue 0 -1 // показать список от 0 до крайнего элемента

**При работе с REDIS in VSC**
* import Redis  
* With - контекстный менеджер, использовать при работе с потоками. Когда заканчивается тело with, он закрывает соединение автоматиечски.  

**Чтобы запустить сервер REDIS с консоли:**  
sudo service redis = server start

**Пример**: 

with redis.Redis() as redis_server:  
redis_server = redis.Redis () - при открытом окне соединения в redis.cli  
rides_server.close () - закрыть соединения  
redis_server.lpush ("queue", 1) // queue - куда, 1 - значение, lpush - поставить в очередь слева  

Чтобы **получить значение справа из очереди в Redis**:  
with redis.Redis() as redis_client:  
value = redis_client.rpop ("queue", 2) // queue - название очереде,(списка), 2 - количество элементов, которые хотим получить 
print (int(value))  

Проблема: rpop - если в очереди нет значений, то программа остановится   
Решение: brpop - будет ждать, пока в очереди не появятся снова задачи, но будет возвращать **Кортеж**, в таком случае:  
print (int(value[1]))  

## OpenCV   
OpenCV - (англ. Open Source Computer Vision Library, библиотека компьютерного зрения с открытым исходным кодом)  

**Для начала работы в VSC:** //скачивает удаленно  
pip install opencv-python  

**Чтобы считать картинку**:  
import cv2  
// + поместить картинку в папку с проектом  
img = cv2.imread('test.jpg')  

**Чтобы поменять размер картинки:**
img = cv2.resize(img, (500,500))  

**Чтобы узнать размер картинки:**   
print(img.shape)  
На выходе: (500, 500, 3), где 3 - говорит о том, что на каждый пиксель 3 канала ( не RGB, а BGR - blue, green, red)  

**Чтобы показать картинку:**  
cv2.imshow ('Result', img) // result - название окна, в котором откроестя img
cv2.waitKey(0) // 0 - картинка будет висеть вечно, если значение > 0, например, 20 - то будет висеть 20 миллисекунд, а потом закроется  

**Чтобы выбрать камеру для распознования лиц:**   
* **если камера:**   
cap = cv2.VideoCapture(0) // 0 - первая камера, если их несколько, выбрать по индексу соответственно  
* **если видео:**  
cap = cv2.VideoCapture('video.mp4') // в папке с проектом  

**Чтобы получать изображения с камеры:**  
while True:
    success, frame = cap.read() // success - if True, frame - переменная, в которую сохраняется картинка  
    cv2.imshow('camera', frame)  
    if cv2.waitKey(1) & 0xff == ord ('q'): break // чтобы выйти из цикла при нажатии q, 1 - обновление (по возможности) каждую миллисекунду, для видео - 1000/fps

Чтобы ввести переменную, в которой будет **классификатор (обученная сетка) для распознования лица**, но можно и под другим признакам, для этого необходимо выбрать другой классификатор на гитхабе:  
face_cascades = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_frontalface_default.xml")  
  * Найти лицо на картинке:  
  faces = face_cascades.detectMultiScale(gray_img) # найти лицо на серой картинке    
print(faces) # выводит массив с данными о том, где найдены лица, в виде: [1,2,3,4], где 1, 2 - координаты начальной точки, 3 - длина, 4 - ширина прямоугальника, в котором найдено лицо  
for x,y,w,h in faces:  // 4 координаты - значения массива  
    cv2.rectangle(img, (x,y), (x+w, y+h), (255,0,0), 2) // рисуем прямоугольник на img, х, у - нач. коорд., далее отсчитываются границы прямоугольника, далее цвет границ, и 2 - толщина границы

Чтобы **конвертировать изображение в серые оттенки**:  
img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) // с изображениями в серых оттенках компьютеру работать значительно проще  

**Словарь (dictionary)**
* **создать словарь**:  
  * d = {}    
  * d = dict()  
  * d = {'up': '↑', 'left': '←', 'down': '↓', 'right': '→', 123: 56456} 

Добавить значение словаря через **.get**:  
arg[i] = arg.get(i,0) + 1  

* **записать значение в словарь**:  
  * d['q'] = 'qwerty', где по ключу 'q' можно вызвать его значение 'qwerty'  
* **найти ключ в словаре по его значению: ** 
list(i.keys())[list(i.values()).index(inp_second_name)] == 'Фамилия' # список ключей [индекса значения в списке значений]  
* **удалить значение** словаря:   
del d ['q']  
* при работе со словарем через цикл:  
for i in d:
    print(i) = q, w - это ключи;
    print(d[i]) = qwerty, ...  
* работа с ключами и значениями:
  * for value in d.values()  
print(value)
  * for key in d.keys()
print(key)

! Словарь, по своей сути, состоит из кортежей из двух элементов {(,), (,), ...} , где 1 элемент - ключ, 2 элемент - его значение  

* Чтобы **вывести словарь** через цикл for:  
  * for k,v in d.items()  
    print(k,v)  
  * for i in d:
    print(f'{i}: {d[i]}')

**Работа с множествами** 
* Чтобы **создать множество**:  
  * colors = {'red', 'green', 'blue'} // похоже на словарь, но без ключа  
  * q = set()
* Чтобы **добавить** элемент:  
colors.add('gray')  
* Чтобы **удалить** элемент:  
colors.remove('red')  
* Чтобы проверить есть ли такой элемент, и **удалить** его **при нахождении** //не выведет ошибку, если такой элемент отсутствует во множестве:  
colors.discard('red')  
* Чтобы **удалить все элементы** из множества:  
colors.clear() # set()  

Операции со множествами в Python:
* **скопировать множество**  
c = a.copy()  
* **объединить 2 множества**  
u = a.union(b) # в итоговом множество окажутся ТОЛЬКО УНИКАЛЬНЫЕ значения  
* итоговое множество со значениями, которые **пристутствуют в обоих множествах (пересечение)**
  * i = a.intersection(b), где а - 1 множество, b - 2-е  
  * i = a & b, где & = intersection (пересечение двух множеств)
* **вычесть из одного множества второе** - это значит вычесть из первого множества значения, которые также имеются во втором множестве
dl = a.difference(b) 
* найти все значения из двух множеств, за исключением пересеченных:  
* q = a.union(b).difference(a.intersection(b))# {1, 21, 3, 13}  
* c = a.difference(b)  
d = b.difference(a)  
l= c.union(d)  

Чтобы создать **замороженное множество**:  
a = frozenset(b) - нельзя изменять

Чтобы **изменить размер букв, регистра** в строке или др. переменной:  
arg.lower()  
arg.upper()  

Чтобы определить **количество одинаковых элементов в строке**, в т.ч. последовательно-идущих:  
s=input()   
t=0   
while "Р"*(t+1) in s:   
t+=1   
if t!=0:   
print(t)   
else:   
print(0)    

Чтобы **перенести код на следующую строку**:  
+\

**Чтобы создать битовый массив:** 
array = bytearray(b'abcdy ')

Чтобы **создать функцию**:  
def Function(x):  
  * чтобы создать функцию с неопределенным количеством аргументов:
  def Function(*args):  
  * **лямбда(lambda) функция**:  
  any_name = lambda a,b: a+b, где lambda - определяет, что это функция, потом определяем принимаемые аргументы (a,b), и после  двоеточие - что делаем (тело кода)   
  p.s. - функцию можно задать и при определенении входных параметров другой функции:  
  def lalalend(lambda a,b: a+b, x)  
    * **Пример** использования функции в функции, а также использования лямбда-функции:  
[lambda_funk.py](./lambda_funk.py)  

Чтобы и**мпортировать функцию** из другого файла (модуля):
* import module_1 - импорт файла  
module_1.function(n)  
  * import module_1 as m1  - чтобы импортировать, **изменив название для 
  использования в нашем текущем проекте**  
  m1.function(n)  
* from module_1 import function - импорт функции   
function(n)  
* Чтобы **импортировать** абсолютно **все функции** из файла:  
from module_1 import *

**Рекурсия python на примере быстрой сортировки:** 
def quicksort(array):
    if len(array) <= 1:
        return array
    else:
        pivot = array[0]
    less = [i for i in array[1:] if i <= pivot]
    greater = [i for i in array[1:] if i > pivot]
    return quicksort(less) + [pivot] + quicksort(greater)
print(quicksort([10, 5, 2, 3]))

**Сортировка слиянием**  
def merge_sort(nums):  
    if len(nums) > 1:  
        mid = len(nums) // 2  
        left = nums[:mid]   
        right = nums[mid:]  
        merge_sort(left)  
        merge_sort(right)  
        i = j = k = 0  
        while i < len(left) and j < len(right):  
            if left[i] < right[j]:  
                nums[k] = left[i]  
                i += 1  
            else: 
                nums[k] = right[j]  
                j += 1  
            k += 1  
        while i < len(left):  
            nums[k] = left[i]  
            i += 1  
            k += 1  
        while j < len(right):  
            nums[k] = right[j]  
            j += 1  
            k += 1  

Чтобы найти **наибольший общий делитель**(НОД) двух чисел:  
  
  * import math  
    math.gcd(f_numb, s_numb)  
  * Алгоритм Евклида:  
  def NOD(first_N, second_N):  
    if first_N == 0 or second_N == 0: return (first_N+second_N)  
    if first_N > second_N:   
        first_N%=second_N  
        return NOD(first_N, second_N)  
    else:   
        second_N%=first_N  
        return NOD(first_N, second_N)  
print(NOD(f_n, s_n))  

* **Функция (map(a,b))** - принимает 2 аргумента. а - функция, которая будет применена к данным b. p.s. применятеся для действий. для усвловий - будет возвращать true/false вместо аргументов данных b.    
basic_list = list(map(lambda x: x+1, basic_list))  
* **Функция (filter(a,b))** - принимает 2 аргумента. а - функция, которая будет применена к данным b  
data = list(filter(lambda x: x%10 == 5, data))  
* **Функция zip()** применяется к набору итерируемых объектов и возвращает итератор с кортежами из элементов входных данных. Крч по итератору добавляет значения в новые кортежи, кот. будут элементами нового списка. Работает по достижению минимального размера одного из входных списков.  
[zip_funk.py](./zip_funk.py)  
* **Функция enumerate()** применяется к итерируемому объекту и возвращает новый итератор с кортежами из индекса и элементов входных данных. ОНА ПОЗВОЛЯЕТ ПРОНУМИРОВАТЬ НАБОР ДАННЫХ  
data = list(enumerate(data)), где data - список данных, которые будут пронумированы   
* **Функция all()** применяется для проверки, все ли элементы коллекции выполняют значение. Возвращает true/false.  
if all(x == list[0] for x in vowels) - проверит каждое значение в списке vowels на равенство первому значению списка list. Например: если list[0] = 4, то все элементы списка vowels должны быть равны 4.  
* **Функция .strip()** Она используется для возврата копии исходной строки путем удаления начальных и конечных пробелов, символов, переданных в функцию strip(). Если передать внутрь функции () символы, можно даже через пробел, то она удалит все такие символы в строке. **Пример:**  
input_str.strip('! Wel * $')
* **Функция reduce()** принимает 2 элемента (1- функция, которая будет применена ко всем элементам итерируемого объекта 2)  
**Пример:**

import reduce  
items = [10, 20, 30, 40, 50]
sum_all = reduce(lambda x,y: x + y, items)
sum_all  

Сортировка python:  
[Сортировка python](./Py_sorting.py) 
+  
Встроенная сортировка Python:
sort(): a.sort()  - меняет текущую коллекцию
sorted(a) - создает новый список с отсортированными данными  
a = sorted(a, reverse=True), где reverse = чтобы инвертировать наоборот. sort () тоже поддерживает   

----->> КОНЕЦ КОДА **PYTHON**

---

# GIT
### **GitHub** - крупнейший веб-сервис для хостинга IT-проектов и их совместной разработки. Мы используем его для работы с удалёнными репозиториями. 
### **Репозиторий** - это хранилище файлов, поддерживающее версионность (историю сохранений (изменений))
> При первом запуске : 
* git config --global user.name "Your Name"  
* git config --global user.email "your.mail@mail.com"
> Команды для работы с GIT:  
* git init - создать локальный репозиторий
* git status - информация о текущем состоянии
* git checkout 12345 - для перехода в другой коммит (нумерация вызывается из лога, переход возможно осуществеить по первым 4-5 цифрам в логе)  
  * git checkout master/main - выйти в текущей версии (голова)  
  * 
* git add hello_world.md - добавить файл "hello_world.md" для отслеживания Git-ом состояния файла и его сохранений в будущем  
  * git add. - добавить все имеющиеся в папке локального репозитория файлы 
* git commit -m "comment" - сохраняет изменения файла (перед этой командой необходимо добавть файл с помощью "add")  
* **git commit -am "comment"** - сразу и добавить файл и закоммитировать его  
* git log - журнал всех изменений (коммитов)  
* git diff - показать отличия текущего (закомиттированного) состояния файла от предыдущего  
* git branch - вывести все ветки проекта
* git merge name_branch - слияние **текущей** ветки с другой
* git branch -d name_branch - удалить ветку
* git chechout branch_name - переключиться на другую ветку
* git branch -m new_name - переименовать ветку
  * git branch -m old_name new_name - переименовать удаленно
* git log --graph - вывести лог коммитов в **графическом** виде   

> Команды для работы с удалёнными репозиториями: 

* git clone hyperlink - клонирует удалённый репозиторий в нашу локальную папку на компьютере 
* git remote rm origin - удалить обявленный удаленный источник  

! После клонирования необходимо перейти в папку скачанного проекта, для этого мы используем команду:  
>cd .\folder - для перехода к скачанному репозиторию  
>cd .. - для перехода выше на одну папку по корневому дереву 

* git push - отправляет файл на удалённый репозиторий  

* git pull - скачать актуальную версию из удалённого репозитория и замерджить с локальным состоянием файла  
* fork (вилка) - на сайте Git, для копирования проекта из чужого репозитория

> Чтобы **игнорировать** перечень файлов:  
Необходимо создать файл **.gitignore** и прописать там файлы, которые необходимо игнорировать  

---

# VISUAL STUDIO CODE  
> Команды:  
* **clear** - очистить консоль
* dotnet new console - создать проект на языке C#
* dotnet run - запустить проект C# в текущей папке  
* Q - когда в консоли висит [END]  
* Ctrl + C - завершить выполнение программы (например, если она зациклилась)  
* Shift + Alt + F - автоматическое форматирование кода
* cd .\folder - для перехода к следующей папке по корневому дереву
* cd .. - для перехода выше на одну папку по корневому дереву 
> Ошибки:  
* **Stack overflow** - переполнение памяти в ячейке (>1Мб), обычно возникает при зацикливании цикла либо слишком большом количестве самовызовов рекурсии

---

# MARKDOWN  

>Чтобы создать файл Markdown -> file.md

> Работа с текстом:  

* Заголовок - #  
* Подзаголовок - ##  
* Еще мельче - ###   
* Полужирный - ** текст **  
* Полужирный + курсив - *** текст ***  
* Курсив - * текст *  
* Список - * или - текст...  
  * Вложенный список - 2 пробела + * или - 
* Нумированный список - 1. текст...  
* Зачеркнутый текст - ~ текст ~  
* Подчеркнуть линией - ___ (3 нижних подчеркивания)  
* Весь текст размером с заголовок - подчеркнуть его "-" или "=" второе больше  
* Цитата - >   
* **Добавить картинку:** 
1. **Из интерента:** ![Описание картинки] (https://picsum.photos/800/600)  
// без пробелов  
2. **Из корневой папки:** ![Текст с описанием картинки] (/images/picture.jpg)  
// без пробелов 
3. **Добавить всплывающий комментарий** - ![Описание картинки] (https://picsum.photos/800/600 "Подпись под картинкой")   
// без пробелов  

* **Добавить ссылку на файл в корневой папке:**  
[task_47.py](./ task_47.py)  

* *Вставить/добавить ссылку:  
[Текст ссыл ки](а дрес "Описание")


---

## Полезные сайты или ссылки на них: 
1. Learn Git branching - сайт для практической отработки навыков работы с Git  
2. Рекомендации по разработке фреймворка .NET - https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/
3. Классификаторы для распознования по видеокамере или видео:  https://github.com/opencv/opencv/tree/4.x/data/haarcascades  
4. Тренировка навыков, решение задач, подготовка к собезам: https://leetcode.com/timofeev-vadim-96/  
5. Решение задач: https://www.hackerrank.com/  
6. Решение задач: https://www.codewars.com/  


 



