# Общая теория
**Языки программиования по количеству** "посредников" между человеком и компилятором делится на 2 типа:
* Интерпретаторы - выводятся построчно (пример - Python)
* Компилляторы - выводится сразу весь код (пример - Java)   

**Ошибки** компилляции бывают 3 типов:  
1. Синтаксические ошибки (неправильно написанные команды, пропущенные знаки, несоблюнеие отступов)
2. Ошибки выполнения (деление на 0)
3. Логические ошибки (программа работает, но не правильно - логика построена не верно)  

Стили оформления кода:  
* Shake_case (от слова snake - змея) (Python)
* CamelCase (от слова camel - верблюд) (C#)

**Массивы** - структура данных, хранящая набор значений (элементов массива), идентифицируемых по индексу или набору индексов  
// пример: гардероб в театре - содержит определенное количество вешалок с определенными номерами. На каждый крючок можно повесить только один элемент одежды (однотипные объекты) 

**Кортеж** (tuple) - частный случай массива или списка, в который нельзя вносить изменения. Значения кортежа пишутся в круглых скобках () . Кортеж занимает меньше памяти и работает быстрее  
(пароли, название хоста)

**Список** - это упорядоченный конечный набор элементов. По сути список - это тот же самый массив, в котором
можно хранить элементы любых типов данных.  

>**Отличие списков от массивов** заключается в том, что список - это динамическая структура, размер которого можно изменять во время выполнения программы (удалять, добавлять элементы)

*Параметры массива:*  
1. Начало массива (адрес первой ячейки с элементами массива)
2. Размер каждого элемента (сколько ячеек памяти занимает каждый элемент массива)
3. Количество элементов в массиве  

**Цикл** - действие, которое выводится множество раз
* while
* for
* foreach

**Фреймворк** - программное обеспечение, облегчающее разработку и объединение разных компонентов большого программного проекта (пример: .NET (для C#), React (для Java), Django (для Python))  

Состав:  
1. Постоянная часть — каркас, не меняющийся от конфигурации к конфигурации  
2. Сменные модули (или точки **расширения**)  

**Правила написания кода**  
1. Код **читается чаще**, чем пишется, не нужно экономить на понятности и чистоте кода ради скорости  
2. Стараться **не использовать** сокращения, кроме общепринятых в разрабатываемом продукте  
3. Не **использовать имена**, потенциально или явно **конфликтующие со стандартными идентификаторами**  
4. Стараться вовсе **не использовать сокращения**  
5. Не использовать **нецензурные слова**  
6. Не использовать **акронимы**  
Пример: ~~SendPM~~ -> SendPrivateMessage  
7. Использовать общие, не привязанные к контексту, имена  
Пример: string ~~str~~ -> string value
8. В С# **имена методов** пишутся **с большой буквы**  
Пример: void Method()  
9. **Избегать длинных строк**, не более 150 символов  
10. Если метод **асинхронный** - он заканчивается на "**Async**"  
Пример: GetStream Async()  
11. Использовать **var**, когда **тип данных не известен** заранее  
12. **Объявлять переменные** непосредственно перед их использованием  
13. **Имена счетчиков**: i, j, k, l, m, n, ...  
14. **Инициализировать переменные** при их объявлении (по возможности)  
15. **Компановать в коде** методы отдельно, свойства отдельно и т.д.  
16. **Комментировать** самые важные части кода, например - **методы**  
17. Использовать **словари** eng/рус  
18. Все константы пишутся большими буквами, CONST = 3,14

**Принципы написания кода**  
* **DRY** - don't repeat yourself - не заниматься копипастом своего кода, думать об автоматизации и переиспользовании  
* **YAGNI** - you aren't gonna next it - вам это не понадобится, не создавать избыточную функциональность  
* **KISS** - keep it simple, stupid - принцип, запрещающий использование более сложных средств, чем необходимо. Принцип декларирует простоту системы в качестве основной цели и/или ценности  

**Легаси (Legacy)** - код, который явно следует переписать, он старый, но очень сложный и работает

> Bit O Notation - время работы алгоритма по верхнему значению 

**Сложность алгоритма** - количество действий, которое необходимо выполнить для получения ответа. Пишется О (n), где n - количество элементов в массиве. 

Нотация O большое говорит о том, чтобы найти такую функцию, которая начиная с какого-то конкретного числа n всегда будет больше нашего значения. 

> Сортировки:  

1. **Сортировка выбором** - суть в том, чтобы запомнить позицию минимального лемента и менять i-й массива с минимальным. Если i-й элемент является min, то он меняется **сам с собой**  

Сложность = n². Память = O (n + 1) // 1 - для temp

2. **Пузырьковая сортировка** - суть в **попарном сравнении** пар элементов и перемещении их в случае необходимости, в итоге крайние элементы массива будут **максимальными.**  

Сложность классической = n², модифицированной = n²/2. Память = O(n)

3. **Быстрая сортировка:**  
  * выбираем из массива элемент, называемый опорным
  * сравниваем все остальные элементы с опорным и переставляем их в массиве так, чтобы разбить массив на 3 части:  
    а) элементы меньше опорного
    б) равные
    в) больше опорного  
  * если длина отрезка (а, б, в) > 1 - повторить  

Сложность = N*logN. Память = O(n) 

4. **Сортировка подсчетом** // только с числами  - целесообразно, когда сортируемые числа имеют достаточно малый диапазон значений по сранвнию с сортируемым множеством, например 1.000 уникальных значений из 1.000.0000  

Суть: Индекс = число // i = 12, значит, что эта ячейка хранит кол-во цифр 12 в массиве. Подсчет идет путем проходки по основному массиву, запись происходит в вспомогательный массив размером abs(min)+max+1

Для отрицательных чисел - учитывать в размере вспомогательного массива, при сравнении числа с индексом учитывать минимальное значение, а именно:  
arr[i] = j - Abs(min)  

Сложность = O(n+k), k - количество уникальных элементов. Память = O (n+k)

## ООП - ОБЪЕКТНО-ОРИНЕТИРОВАННОЕ ПРОГРАММИРОВАНИЕ 
**ООП** - подход к написанию программного обеспечения  
Принципиально, ООП состоит из:  
1. Описание объекта
2. Описание его поведения

**Принципы ООП** - это как перенос реального объекта в виртуальный мир. Например: описание котика кодом :) + сделать так, чтобы этот котик мог взаимодействовать с другими объектами (его поведение)  

**Суть ООП** - представить программу в виде объектов, которые каким-то образом взаимодействуют друг с другом  

---

## Базы данных  

**СУБД** - система управления базами данных  

**База данных** - предн. для хранения, обработки и быстрого извлечения необходимой информации  

**Реляционные базы данных** (relations - отношения) - базы данных, в которых данные распределены по отдельным, связанным между собой, таблицам

id - уникальный идентификатор (для первичной таблицы - **первичный ключ**, для остальных - **внешний ключ**)  

**Создание структуры базы данных:**

"Поле", "Тип", "Длина(размер)", "Комментарий"

  * Тип: 
    * Date  
    * Int  
    * Text  
    * Time  
    * TimeStamp - отсечка уникального момента во времени  
    * Real - как float, только автомат. определяет кол-во значений после запятой  

**Правила создания баз данных** от Камянецкого:  
1. Чем больше атрибутов - тем лучше
2. Всегда иметь идентификатор
3. Если кажется, что индентификатор не пригодится, читай п. 2  
4. DRY - don't repeat yourself - если хочешь что-то скопировать, то, скорее всего, нужно создавать новую таблицу
5. Не лишним будет выработать свой стиль (имена могут быть зарезервированы, если они простые, очевидные)  
6. Визуализировать: лучше 1 раз увидеть, чем 100 раз услышать
7. У одной системы может быть несколько БД, у нескольких систем не может быть одна БД (чтобы из-за одной БД не легли все системы)
8. Иметь tag - системное поле на всякий случай  
9. Select*From table_name - лучше так не делать, чтобы не вытянуть всю инфу вместе с ненужной после ее редактирования

Некотороые ячейки необходимо **разбивать**, например:  

**Телефон:**
  * +7/+44 - страна  
  * (985) - оператор  
  * 123 45 67 - абоненский тел. номер  

**Адрес:**  
  * страна  
  * субъект  
  * город  
  * улица
  * дом
  * строение
  * корпус
  * квартира / помещение  

**ФИО**  
  * Фамилия
  * Имя
  * Отчество  

**Типовые размеры полей:**  
1. Дата рождения - 8
2. Телефон - 16
3. id - 10
4. Комментарий - 100
5. Имя/фамилия/отчество - по 30
6. Паспорт_серия - 10
7. Паспорт_номер - 20
8. Гос. номер авто - 16
9. TimeStamp - 12

**Типы связей в таблице:**  
* 1 к 1: ребенок - мать  
* 1 ко многим: мать - 1 и более ребенок 
* многие ко многим:  1 человек - несклько адресов, 1 адрес - несколько людей   

**Коллекции данных:**   
* Список  
* Словарь  
* Множество 

**Словари** — неупорядоченные коллекции произвольных объектов с доступом по ключу. В списках в качестве ключа используется индекс элемента. В словаре для определения элемента используется значение ключа (строка, число).  
! Словарь может содержать разные типы данных (int, string, массивы, списки, словари и т.д.) 

**Множество** -  содержит в себе **уникальные элементы**, **не упорядоченные**. Одно множество может содержать значения любых типов. НЕЛЬЗЯ добавитьв множество элемент, который в нем уже содержится.

----->> КОНЕЦ ОБЩЕЙ ТЕОРИИ

---

# SQL  

* Извлечение данных из таблицы:  
Примеры:
  * **из одной таблицы:**  
    Select * From - Общий список, где:  
    * Общий список - название таблицы  
    * Select - указываем набор столбцов  
    * "*" - означает, что мы хотим видеть все столбцы  
    * From - откуда необходимо выбрать информацию    

  * *Если не все столбцы:  *
    * Select Фамилия, Тел., Комментарий  
    * From Общий список  
    * Where статус = "холост" // в SQL знак " = " - это сравнение  

  *  **из нескольких таблиц:**  
    Select * From peoples;  
    Select * From addresses;  
    Select * From peoples LeftJoin addresses ON peoples.identifier = addresses.Whose_addresses;  

  *  *Если необходимо выбрать таблицы по столбикам:*  
    Select  
      peoples.full_name,  
      peoples.status,  
      telephones.phone_number  
    From peoples LeftJoin telephones ON peoples.identifier = telephones.whose_phone  

> Команды SQL  

like - содержит в себе  
Пример: select * from ученики where характеристика like *'ленив'*;  

Чтобы **обратиться к полю с пробелом**, необх. взять его в квадратные скобки []  
Пример:  Классы.[Номер класса]

>Присоединение таблиц  

* Inner Join - покажет все элементы, где есть соответствие между таблицами
* Left Join - покажет все элементы левой таблицы + элементы правой таблицы, которые соответствуют элементам левой таблицы
* Right Join - покажет все элементы правой таблицы + элементы левой таблицы, которые соответствуют элементам левой таблицы  
* Full Join - покажет все элементы обеих таблиц  

**Пример**: Left Join Люди, адреса on id = чей адрес

---

## Microsoft Access  
Реляционная система управления базами данных (СУБД) корпорации Microsoft.   

**2 режима** работы с таблицей: 1 - заполнение таблицы, 2 - конструктор таблицы  

! Для работы со **схемой базы данных**, необходимо закрыть все таблицы  
  * Работа с базами данных - схема данных

Чтобы **создать запрос**  
* создание - мастер запросов  
* создание - конструктор запросов - SQL  



----->> КОНЕЦ БАЗ ДАННЫХ

---

## Формулы
> Определение расстояния между 2-мя точками в 2D пространстве:  
Дано: A (xa, ya), B (xb, yb)  
AB = √((xb - xa)² + (yb - ya)²)  

> Определение расстояними между 2-мя точками в 3D пространстве:  
Дано: A (xa, ya, za), B (xb, yb, zb)  
AB = √((xb - xa)² + (yb - ya)² + (zb - za)²) 

---

# C#  
**Арифметические операции:**
* i++ (i = i + 1) - инкремент
* i-- (i = i - 1) - дискремент
* // - деление нацело, без остатка, с округлением  
* && - И (должны быть соблюдены оба условия)
* || - ИЛИ (должно быть соблюдено лишь одно условие)  

> Чтобы сделать комментарий к коду - //, временный комментарий - // TODO:

**Типы данных:**
* char - символ  
* string - строка
* int - целое число
* float - дробное число
* double - дробное число, с большим количеством памяти, выделяемых под него
* bool - логические тип  
* var - автоматическое определение типа данных  

**Интерполяция**  - для выведения значения переменных в контексте
// пример: WrileLine($"переменная x = {x}") Ключевой момент - использование знака доллара перед ковычками  

**Конкантенация** - операция склеивания объектов линейной структуры, обычно строк  
// пример:  WrileLine("текст" + arg)  

>> КОМАНДЫ: // (переменная - arg)  

___
----->> НАЧАЛО КОДА **C#**
___

\t - **табуляция** между элементами, к примеру, массива  

\n - **с новой строки** 

Console.WriteLine("Hello, World!"); - **вывод в консоль**

Console.ReadLine(); - **считывание вводимых пользователем данных**

переменная.ToLower - **игнорирует размер букв** (например: "МаШа")

Чтобы **возвести в степень**:  
math.pow(x,y) x - число, y - в какую степень его возвести  

Чтобы получить **квадратный корень:**   
Math.Sqrt(x)  
или * 1/2  

Чтобы **округлить**:  
Math.Round (d, 3), где d - переменная, 3 - количество знаков после запятой

**Чтобы конвертировать в int**  
Convert.ToInt32(arg) / int.Parse(arg) // 32 - в десятичное число  

Чтобы **задать/объявить пустую строковую переменную**:  
string arg = String.Empty; или = "";

Чтобы **создать массив:** 
   * одномерный: int [] arr = new int [size];  
   * вмумерный: int [,] arr = new int [rows,columns];  
   * трехмерный: int [,,] arr = new int [length,width, height];  


Чтобы **вывести массив:**  
  * Для **одномерного** массива:  
    * WriteLine(String.Join(", ", arr)); где ", " - сепаратор, arr - массив
    * for (int i = 0; i < arr.Length; i++)  
{  
    System.Console.Write(arr[i] + "\t");  
    // "t" - табуляция, Write - чтобы в одну строку  
}  
  * Для **двухмерного** массива:
    for (int i = 0; i < rows * columns; i++)  
{  
    if (i%columns == 0) System.Console.WriteLine();   
    // перенос на следующую строку, когда количество итераций будет кратно значению columns  
    System.Console.Write(arr[i / columns, i % columns] + "\t");   
    // "t" - табуляция, Write - печать в одну строку   
}

Чтобы **задать рандомное значение элементу**:  
  * **целое число:**  
  int arg = new Random().Next(1,10); 
  int arg = Random.Shared.Next(left,right);
  * **дробное число:**  
  arg = new Random().NextDouble(); //значения будут в промежутке от 0 до 1, для того, чтобы получить значения > 1, просто умножить на 10 или 100 и т.д.  
  *  **чтобы сократить рандомайзер**:  
  Random rand = new Random();  
  и далее используем переменную -> rand.Next();  
* Чтобы **создать массив из рандомных элементов**:  
int [] arr = new int [N].Select (r => rand.Next(0,5)).ToArray(); // r - объявлять не нужно

Чтобы **заполнить двухмерный массив с помощью одного цикла:**  
for (int i = 0; i < rows * columns; i++)  
{  
    arr[i / columns, i % columns] = new Random().Next(1, 10);   
}  

Чтобы **заполнить массив строк** при вводе с клавиатураы:  
string [] arr = console.ReadLine().Split(" "); // будет заполнять массив при вводе данных через **пробел**  

Чтобы **заменить символ**:  
arg.Replace("что заменить","на что");  

Чтобы создать документацию к методу:  /// 

>**Тернарный оператор**  
**Пример**:  
res += arr[i] > 0 ? arr [i] : 0;  
// arr [i] > 0 (**истина**): res += arr [i];  
// array [i] > 0 (**ложь**): res += 0;  

**MAX и MIN для сравнения чисел:**  
*принцип придания абсурдности*
  * min = int.MaxValue;  
  * max = int.MinValue.  

**Чтобы конвертировать в string**  
arg.ToString();  

Чтобы **сократить логические код**:  
  * На примере "**проверка на четность**"  
  bool IsEven (int value)  
  {  
    return value % 2 = 0; // true/false  
  }  

Чтобы **узнать тип переменной (данных)**:  
Console.WriteLine(arg.GetType().Name);  

Чтобы **вычленить из типа string данные** для дальнейшего использования:  
string text = "(1,2) (3,4) (5,6) (7,8)";  
var data = text.Split(" ").ToArray(); // теперь это массив данных ->   
Результат: string [] data = [(1,2),(3,4),(5,6),(7,8)]  

Чтобы **запустить файл программы:**  

1. **Вручную в папке**: ...\Знакомство с С#\Семинар 3\HW_sem3\bin\Debug\net6.exe  
2. **Из cmd**: cd C:\Users\...\bin\Debug\net6.0  
start file.exe    

Чтобы **засечь время выполнения** куска кода:   

using System.Diagnostic;  
Stopwatch sw = new();  
sw.Start();
...  
sw.Stop();  
Console.WriteLine.ElapsedMilliseconds; // вывод результата в миллисекундах   
sw.Reset(); // обнулить таймер  

Чтобы **не писать Console**....  
using static System.Console;  

Чтобы **не писать String**....  
using static System.String;  

Чтобы **вывести методы красиво:**  
перед типом переменной в () после объявления метода добавить "this"  
**Пример**: int Method (this int [] ...) // нельзя исп-ть с void типом  
**Итог**:  
10.CreateArray().Show().SortSelection().Show(); // 10 - размер массива

Чтобы **прописать исключение**, при котором заканчивается выполнение программы с выводом текста:  
if (...) throw new Exception ("...");

> Чтобы создать поток:  

int eachThreadCalc = N/THREADS_NUMB;//**количество элементов на поток**  
var threadsList = new List<Thread>();// **создаем поток**   
for (int i = 0; i < THREADS_NUMB; i++)  
{  
    int startpos = i*eachThreadCalc;  
    int endpos = (i+1)*eachThreadCalc;  
    if (i == THREADS_NUMB-1) endpos = N; //**для последнего потока остаток значений**  
    threadsList.Add(new Thread(() => ProductOfParallelMatrices(Matrix1,Matrix2, startpos, endpos)));  
    //**каждому потоку распределили что он должен делать** 
    threadsList[i].Start(); //**запускаем поток**  
}  
for (int i = 0; i < THREADS_NUMB; i++)  
{  
    threadsList[i].Join();// **ждем, пока все потоки будут готовы** (посчитают задание)  
}   

Чтобы заблокировать пуск кода для других потоков:  
object = locker = new object();
lock (locker) // locker - команда блокировки   
{  
    code  
}

**namespace** - пространство имен  

Чтобы вывести строку из рандомных элементов, букв, цифр:  

var arg = $"Name{Guid.NewGuid().ToString().Substring(0,5)}" 

Чтобы взять **модуль числа**:  

Abs(number) // не забыть System.Math;  

Чтобы **скопировать массив в другой** массив:  
arr.Copy(arr1, arr2, size);


> Клиент - сервер  

Потоки могут быть:  

1. < Thread > - поток исполнения
2. < Stream > - поток данных

Тип данных для поток записи - StreamWriter (данные с клиента на сервер)  
Тип данных для поток чтения - StreamReader  

Связь TCF - требует постоянное соединение, в случае разрыва - сервер упадет 

>Чтобы **хостить на своем компьютере IP - ip 127.0.0.1**  

Типы запросов: 
- get - получить, read (R)  
- put - обновить, update (U)  
- post - создать, create (C)  
- delite - удалить, delete (D)

___
----->> КОНЕЦ КОДА  **C#**
___

> Работа с директориями  
* Чтобы **получить информацию о папке**:    

string path = "C:/Users/DELL/Desktop/...; - **путь к папке**  
DirectoryInfo di = new DirectoryInfo(path);
Console.WriteLine(di.CreationTime); // **возвращает время создания папки**

void CatalogInfo(string path, string indent = " ")  
{  
DirectoryInfo catalogs = new DirectoryInfo(path);  
foreach (var currentCatalog in catalogs.GetDirectories()) // **возвращает список подпапок**
{  
Console.WriteLine($"{indent}{currentCatalog.Name}");  

CatalogInfo(currentCatalog.FullName, indent + " ");  
}  
foreach (var item in catalogs.GetFiles()) // **возвращает список папок текущей директории**  
{  
Console.WriteLine($"{indent}{item.Name}");  
}  
}    
CatalogInfo(path);  

> МЕТОДЫ 

**4 типа методов:**
1. *Ничего не принимает и ничего не возвращает*  
**Пример:**
void Method1()  
{  
    Console.WriteLine("Text");  
}  
Method1(); - **Чтобы вызвать метод** 
2. *Ничего не принимает, но что-то возвращает*  
**Пример:** 
void Method2(string msg)  
{  
Console.WriteLine(msg);  
}  
Method2(msg: "Текст сообщения"); - метод ничего не принимает, значение переменной msg мы прописываем при его вызове
3. *Ничего не принимает и ничего не возвращает*  
**Пример:**  
int Method3()  
{  
    return DateTime.Now.Year;  
}    
int year = Method3();
Console.WriteLine(year); 
4. Что-то принимает и что-то возвращает  
**Пример:**   
string Method4 (int count, string c)  
{  
    int i = 0;    
    string result = String.Empty; 
    while (i < count)  
    {  
        result = result + c;  
        i++;  
    }   
    return result;  
}  
string res = Method4(10, "qwerty");  
Console.WriteLine(res);

> **РЕКУРСИЯ**   

У рекурсии 2 случая:  
1. базовый - условие для выхода из рекурсии  
2. рекурсивный - вызов функции самой себя  

**На примере чисел Фибоначчи**

// f(1) = 1  
// f(2) = 1  
// f(n) = f(n-1) + f(n-2)  
double Fibonacci(int n)  
{  
    if (n == 1 || n == 0) return 1;  
    else return Fibonacci(n-1) + Fibonacci(n-2);  
}  
for (int i = 0; i <= 45; i++)  
{  
    System.Console.WriteLine($"{i} = {Fibonacci(i)}");  
}  

**На примере программы для перевода из десятичного кода в бинарный**  

int N = 15;  
void ToBinary (int num)  
{  
    if (num == 0) // выход из рекурсии  
    {  
        return;  
    }  
    ToBinary(num/2);  
    System.Console.Write(num%2);  
}  
ToBinary(N); // - вызов метода  

**На примере Факториала**  
int Factorial (int N)  
{  
    if (N == 1) return 1; // базовый случай  
    return N*Factorial(N-1); //рекурсивный случай  
}

---

# PYTHON  
## Python - язык с динамической типизацией (переменная может быть переопределена в теле кода)  

* **Виртуальное окружение** (virtual environment)  
Чтобы создать -> python3 -m venv .folder  

* Чтобы **запустить компилляцию**:  
1. Ctrl + F5  
2. python file.py   
3. кнопка в правой части экрана  

**Базовые типы данных Python**  
int  -||-  
float -||-  
bool  -||-   
str  - строка   

**Арифметические операции:**
* i+=1 (i = i + 1) - инкремент
* i-=1 (i = i - 1) - дискремент  
* i*=1 (i = i * 1)  
* i/=1 (i = i / 1) - получится **вещественное значение**
* i//=1 (i = i // 1)  - деление нацело, без остатка, с округлением  
* i%=1 (i = i % 1) - остаток от деления  
**Логические операторы:**
* and - И (должны быть соблюдены оба условия)
* or - ИЛИ (должно быть соблюдено лишь одно условие)  
* not - не (отрицание)  
* elif - else if  
* else - **при использовании после цикла** While - случай, когда основное тело цикла перестает работать самостоятельно (выполнено условие для выхода из цикла)  

>> КОМАНДЫ: // (переменная - arg) 

----->> НАЧАЛО КОДА **PYTHON**  

>**Переменные объявляются** без их типов  
пример:  number = 5  

Чтобы **создать пустую переменную**:  
arg = None  

Чтобы **создать строковую переменную**:  
arg = 'qwerty' or "qwerty"  

Чтобы сохранить **тип переменной(данных)**:  
type(n)  

Чтобы вывести в "print" ковычки, поставить \ перед знаком  
Пример: 'fd\'fd' = fd'fd  

>**Чтобы комментировать код:**  
\# - для одной строки  
\### - (перед 1 и крайней строкой) многострочный комментарий  
Ctrl + K + Ctrl + C - многострочный комментарий  
CTRL + / - комментировать все, что выделено  

**Чтобы вывести данные:** 
print(f"{a} = arg qwerty"), где f - символ интерполяции  

**Чтобы ввести данные:**   
* input(),   -  ввод будет осуществлен на след. строке
* input('введите сообщение'), - ввод будет осуществлен на той же строке, при этом приветственное сообщение нигде не сохраняется, а лишь является инструкцией для ввода данных. Введенные данные будут иметь **тип string**  

Чтобы привести данные (**приведение типов** данных):  
n = int(c) / b = int(input('text'))  

**Цикл for (фор)**  
Пример:  
for in in arr (по всей его длине) / range(5) - от 0 до 4 / range(2,10) - от i=0 to 9 / range(0,10,2) - где 2 - это шаг  
* range выдает значение из диапазона с шагом 1 в базовом случае  
* если указано только одно число (значение переменной), то от 0 до числа (значения переменной)  
* третий аргумент в range **задает шаг**  

Чтобы **использовать длину** массива (переменной):  
len()  

Чтобы **проверить есть ли строка в строке** с логическим ответом:  
print('qwerty' in text), где text - строковая переменная, результат будет true or false  

Чтобы **перевести текст в нижний регистр**:  
print (text.lower())  

Чтобы **перевести текст в верхний регистр**:  
print (text.upper())  

Чтобы **заменить символы в строковой переменной**:  
print (text.replace ('text', 'TEXT'))  

> Индексация - срезы  

**Примеры**:  
text = 'булки'  
text [ 0 ]  = 'б'  
text [ - 1 ] = 'и' - **индексация с конца** со знаком отрицания  
print ( text [ : 2 ] ) = 'бу', т.к. от 0 до < 2  
print ( len ( text ) - 2 : ) = это значит от 2 с конца до конца = 'ки'  
text [ 2 : 9 ] = со 2 по 8  
text [ 0 : len ( text ) : 6 ] = от 0 до len -1 **с шагом** 6  
text [ ::6 ] = от начала до конца **с шагом** 6  

Чтобы **напечатать (вывести) "сырую" строку**, не обращая внимания на пемененные и фигурные скобки:  
print ( r 'qwerty {x} qwerty '), r - raw ( сырая )

Чтобы **импортировать библиотеку PYTHON**:  
import math  - математика
import cmath - сложная математика  
import random - для создания случайных значений  
import cv2 - для работы с Open CV

Чтобы **округлить**:  
* в большую сторону - math.ceil (2.4 - > 3)  
* в меньшую сторону - math.floor (7.99 - > 7)  
* откинуть дробную часть - math.trune (2.3 - > 2)  

Чтобы **получить правую часть дроби**:  
%1 (6.88 -> 0.88)  

Способоы **задать переменную**:  
* a = b = 1  
* a, b, c = 2

Чтобы **задать массив**:  
arr = [0] * 10 # массв, размером 10, заполненный нулями   

Чтобы **создать кортеж**:  
t = () - пустой кортеж  
t = (1, ) - кортеж со значениями, после нулевой переменной - обязательно **запятая**. Далее - нет необходимости  
* Чтобы перевести массив или спсок в кортеж:  
t = tuple(v), где v - список или массив  
* Чтобы "**распаковать кортеж**" необходимо количество переменных, равных значению кортежа:  
v = (1,2,3)  
a,b,c = v  
print(a,b,c)  =>  1, 2, 3

Чтобы **записать строку в массив**:  
S = input().split()  
A = [ len (s) ] 
A = [ int(i) for i in S ]  

Чтобы **что-то добавить (append) в список (list)**:  
for i in list:  
new_list.append (int(i))  

Чтобы **создать список**:  
* list_1 = [] # **Создание пустого** списка
* list_2 = list() # Создание пустого списка
* list_1 = [7, 9, 11, 13, 15, 17]  

**Генератор списка**  // фишка Python
* обычный способ  
list_1 = []  
for i in range(1, 101):  
list_1.append(i)  
print(list_1) # [1, 2, 3,..., 100]  
* **с помощью генератора**  
list_1 = [i for i in range(1, 101)]# [1, 2, 3,..., 100]  
  * с условием:  
  list_1 = [i for i in range(1, 101) if i % 2 == 0]# [2, 4, 6,..., 100]  
  * пара из чисел с условием:  
  list_1 = [(i, i) for i in range(1, 101) if i % 2 == 0]# [(2, 2), (4, 4),..., (100, 100)]  
  * можно муножать, делить и т.д. итемы i:  
  list_1 = [i * 2 for i in range(10) if i % 2 == 0] # [0, 4, 8, 12, 16]  

* **создать список с клавиатуры:**  
A = list (map (int, input ().split())), где map: 1 - тип, например int, 2 - составной тип данных (список)  

Чтобы **вывести список**:  
* print(list_1) - выведится с квадратными скобками  
* print(*list_1) - выведится без скобок, через запятую  

Чтобы **добавить** в список элемент:  
list_1.append(8) - в конец списка  
list_1.insert(2,11) - цифра 11 добавляется на 2 позицию, при этом все остальные элементы списка смещаются вправо

Чтобы **удалить** элемент списка:  
list.pop() - удаляет последний элемент
list.pop(0) - удаляет конкретный элемент по индексу
Кроме того, pop - возвращает значение,   
пример: a = list.pop()  
print (a) : a = list(-1)

Чтобы **вывести массив**:  
1. for i in range (len A):  // выводит массив в 1 строку  
print (A[i], end = " ")  
2. for x in A:  
print (x, end = " ")  
3. print (*A) // * - означает, что необходимо преобразовать массив в набор отдельных значений 

Чтобы добавить случайные (рандомные) значения в список:  
* использовать **random.randint ()**  
**Пример**:   
import random  
ran_list = []  
n = 10  
for i in range (n)  
rand_list.append(random.randint(3,9))  
print(rand_list)  

* использовать **random.sample ()** // похоже, не работает с отрицательными числами  
**Пример**:  
import random  
res = random.sample(range(1,50), 7) // 7 - размер списка  
print("Random number list is: " + str(res))  

> Очереди задач Python  

**принцип FIFO** - first in, first out:  
Данные поступают в очередь с конца, а выходят с головы (все как в обычной очереди к кассе - первый зашел, первый вышел)  

**принцип двусторонней очереди**:  
Войти и выйти можно с обеих сторон  

> **REDIS** - база данных (No SQL) - хранит БД в оперативной памяти, что позволяет обрабатывать большое количество запросов /sec.   
P.s. с обычной базой данных мы можем выполнять лишь, примерно, 150-200 операций /sec.  

p.s. - вся информация на REDIS хранится **в байтах**

Команды для работы с **REDIS**:  
* set name Vadim  // или любая другая переменная со своим значением
* get name  
* Keys * // вывести все значения  
* LRANGE queue 0 -1 // показать список от 0 до крайнего элемента

**При работе с REDIS in VSC**
* import Redis  
* With - контекстный менеджер, использовать при работе с потоками. Когда заканчивается тело with, он закрывает соединение автоматиечски.  

**Чтобы запустить сервер REDIS с консоли:**  
sudo service redis = server start

**Пример**: 

with redis.Redis() as redis_server:  
redis_server = redis.Redis () - при открытом окне соединения в redis.cli  
rides_server.close () - закрыть соединения  
redis_server.lpush ("queue", 1) // queue - куда, 1 - значение, lpush - поставить в очередь слева  

Чтобы **получить значение справа из очереди в Redis**:  
with redis.Redis() as redis_client:  
value = redis_client.rpop ("queue", 2) // queue - название очереде,(списка), 2 - количество элементов, которые хотим получить 
print (int(value))  

Проблема: rpop - если в очереди нет значений, то программа остановится   
Решение: brpop - будет ждать, пока в очереди не появятся снова задачи, но будет возвращать **Кортеж**, в таком случае:  
print (int(value[1]))  

## OpenCV   
OpenCV - (англ. Open Source Computer Vision Library, библиотека компьютерного зрения с открытым исходным кодом)  

**Для начала работы в VSC:** //скачивает удаленно  
pip install opencv-python  

**Чтобы считать картинку**:  
import cv2  
// + поместить картинку в папку с проектом  
img = cv2.imread('test.jpg')  

**Чтобы поменять размер картинки:**
img = cv2.resize(img, (500,500))  

**Чтобы узнать размер картинки:**   
print(img.shape)  
На выходе: (500, 500, 3), где 3 - говорит о том, что на каждый пиксель 3 канала ( не RGB, а BGR - blue, green, red)  

**Чтобы показать картинку:**  
cv2.imshow ('Result', img) // result - название окна, в котором откроестя img
cv2.waitKey(0) // 0 - картинка будет висеть вечно, если значение > 0, например, 20 - то будет висеть 20 миллисекунд, а потом закроется  

**Чтобы выбрать камеру для распознования лиц:**   
* **если камера:**   
cap = cv2.VideoCapture(0) // 0 - первая камера, если их несколько, выбрать по индексу соответственно  
* **если видео:**  
cap = cv2.VideoCapture('video.mp4') // в папке с проектом  

**Чтобы получать изображения с камеры:**  
while True:
    success, frame = cap.read() // success - if True, frame - переменная, в которую сохраняется картинка  
    cv2.imshow('camera', frame)  
    if cv2.waitKey(1) & 0xff == ord ('q'): break // чтобы выйти из цикла при нажатии q, 1 - обновление (по возможности) каждую миллисекунду, для видео - 1000/fps

Чтобы ввести переменную, в которой будет **классификатор (обученная сетка) для распознования лица**, но можно и под другим признакам, для этого необходимо выбрать другой классификатор на гитхабе:  
face_cascades = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_frontalface_default.xml")  
  * Найти лицо на картинке:  
  faces = face_cascades.detectMultiScale(gray_img) # найти лицо на серой картинке    
print(faces) # выводит массив с данными о том, где найдены лица, в виде: [1,2,3,4], где 1, 2 - координаты начальной точки, 3 - длина, 4 - ширина прямоугальника, в котором найдено лицо  
for x,y,w,h in faces:  // 4 координаты - значения массива  
    cv2.rectangle(img, (x,y), (x+w, y+h), (255,0,0), 2) // рисуем прямоугольник на img, х, у - нач. коорд., далее отсчитываются границы прямоугольника, далее цвет границ, и 2 - толщина границы

Чтобы **конвертировать изображение в серые оттенки**:  
img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) // с изображениями в серых оттенках компьютеру работать значительно проще  

**Словарь (dictionary)**
* **создать словарь**:  
  * d = {}    
  * d = dict()  
  * d = {'up': '↑', 'left': '←', 'down': '↓', 'right': '→', 123: 56456}  
* **записать значение в словарь**:  
  * d['q'] = 'qwerty', где по ключу 'q' можно вызвать его значение 'qwerty'  
* **удалить значение** словаря:  
del d ['q']  
* при работе со словарем через цикл:  
for i in d:
    print(i) = q, w - это ключи;
    print(d[i]) = qwerty, ...  

! Словарь, по своей сути, состоит из кортежей из двух элементов {(,), (,), ...} , где 1 элемент - ключ, 2 элемент - его значение  

* Чтобы **вывести словарь** через цикл for:  
  * for k,v in d.items()  
    print(k,v)  
  * for i in d:
    print(f'{i}: {d[i]}')

**Работа с множествами** 
* Чтобы **создать множество**:  
  * colors = {'red', 'green', 'blue'} // похоже на словарь, но без ключа  
  * q = set()
* Чтобы **добавить** элемент:  
colors.add('gray')  
* Чтобы **удалить** элемент:  
colors.remove('red')  
* Чтобы проверить есть ли такой элемент, и **удалить** его **при нахождении** //не выведет ошибку, если такой элемент отсутствует во множестве:  
colors.discard('red')  
* Чтобы **удалить все элементы** из множества:  
colors.clear() # set()  

Операции со множествами в Python:
* **скопировать множество**  
c = a.copy()  
* **объединить 2 множества**  
u = a.union(b) # в итоговом множество окажутся ТОЛЬКО УНИКАЛЬНЫЕ значения  
* итоговое множество со значениями, которые **пристутствуют в обоих множествах (пересечение)**
i = a.intersection(b), где а - 1 множество, b - 2-е  
* **вычесть из одного множества второе** - это значит вычесть из первого множества значения, которые также имеются во втором множестве
dl = a.difference(b) 
* найти все значения из двух множеств, за исключением пересеченных:  
* q = a.union(b).difference(a.intersection(b))# {1, 21, 3, 13}  
* c = a.difference(b)  
d = b.difference(a)  
l= c.union(d)  

Чтобы создать **замороженное множество**:  
a = frozenset(b) - нельзя изменять


----->> КОНЕЦ КОДА **PYTHON**

---

# GIT
### **GitHub** - крупнейший веб-сервис для хостинга IT-проектов и их совместной разработки. Мы используем его для работы с удалёнными репозиториями. 
### **Репозиторий** - это хранилище файлов, поддерживающее версионность (историю сохранений (изменений))
> При первом запуске : 
* git config --global user.name "Your Name"  
* git config --global user.email "your.mail@mail.com"
> Команды для работы с GIT:  
* git init - создать локальный репозиторий
* git status - информация о текущем состоянии
* git checkout 12345 - для перехода в другой коммит (нумерация вызывается из лога, переход возможно осуществеить по первым 4-5 цифрам в логе)  
  * git checkout master/main - выйти в текущей версии (голова)  
  * 
* git add hello_world.md - добавить файл "hello_world.md" для отслеживания Git-ом состояния файла и его сохранений в будущем  
  * git add. - добавить все имеющиеся в папке локального репозитория файлы 
* git commit -m "comment" - сохраняет изменения файла (перед этой командой необходимо добавть файл с помощью "add")  
* **git commit -am "comment"** - сразу и добавить файл и закоммитировать его  
* git log - журнал всех изменений (коммитов)  
* git diff - показать отличия текущего (закомиттированного) состояния файла от предыдущего  
* git branch - вывести все ветки проекта
* git merge name_branch - слияние **текущей** ветки с другой
* git branch -d name_branch - удалить ветку
* git chechout branch_name - переключиться на другую ветку
* git branch -m new_name - переименовать ветку
  * git branch -m old_name new_name - переименовать удаленно
* git log --graph - вывести лог коммитов в **графическом** виде   

> Команды для работы с удалёнными репозиториями: 

* git clone hyperlink - клонирует удалённый репозиторий в нашу локальную папку на компьютере 
* git remote rm origin - удалить обявленный удаленный источник  

! После клонирования необходимо перейти в папку скачанного проекта, для этого мы используем команду:  
>cd .\folder - для перехода к скачанному репозиторию  
>cd .. - для перехода выше на одну папку по корневому дереву 

* git push - отправляет файл на удалённый репозиторий  

* git pull - скачать актуальную версию из удалённого репозитория и замерджить с локальным состоянием файла  
* fork (вилка) - на сайте Git, для копирования проекта из чужого репозитория

> Чтобы **игнорировать** перечень файлов:  
Необходимо создать файл **.gitignore** и прописать там файлы, которые необходимо игнорировать  

---

# VISUAL STUDIO CODE  
> Команды:  
* **clear** - очистить консоль
* dotnet new console - создать проект на языке C#
* dotnet run - запустить проект C# в текущей папке  
* Q - когда в консоли висит [END]  
* Ctrl + C - завершить выполнение программы (например, если она зациклилась)  
* Shift + Alt + F - автоматическое форматирование кода
* cd .\folder - для перехода к следующей папке по корневому дереву
* cd .. - для перехода выше на одну папку по корневому дереву 
> Ошибки:  
* **Stack overflow** - переполнение памяти в ячейке (>1Мб), обычно возникает при зацикливании цикла либо слишком большом количестве самовызовов рекурсии

---

# MARKDOWN  

>Чтобы создать файл Markdown -> file.md

> Работа с текстом:  

* Заголовок - #  
* Подзаголовок - ##  
* Еще мельче - ###   
* Полужирный - ** текст **  
* Полужирный + курсив - *** текст ***  
* Курсив - * текст *  
* Список - * или - текст...  
  * Вложенный список - 2 пробела + * или - 
* Нумированный список - 1. текст...  
* Зачеркнутый текст - ~ текст ~  
* Подчеркнуть линией - ___ (3 нижних подчеркивания)  
* Весь текст размером с заголовок - подчеркнуть его "-" или "=" второе больше  
* Цитата - >   
* **Добавить картинку:** 
1. **Из интерента:** ![Описание картинки] (https://picsum.photos/800/600)  
// без пробелов  
2. **Из корневой папки:** ![Текст с описанием картинки] (/images/picture.jpg)  
// без пробелов 
3. **Добавить всплывающий комментарий** - ![Описание картинки] (https://picsum.photos/800/600 "Подпись под картинкой")   
// без пробелов  

---

## Полезные сайты или ссылки на них: 
1. Learn Git branching - сайт для практической отработки навыков работы с Git  
2. Рекомендации по разработке фреймворка .NET - https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/
3. Классификаторы для распознования по видеокамере или видео:  https://github.com/opencv/opencv/tree/4.x/data/haarcascades





