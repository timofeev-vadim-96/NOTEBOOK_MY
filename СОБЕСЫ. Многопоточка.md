# Многопоточка

[Назад](./СОБЕСЫ.md)    

> Что будет, если применить synchronized к статическому методу?

Если сделать статический метод синхронизированным, то блокировка будет на классе, а не на объекте.

> Что является монитором при вызове синхронизированного СТАТИЧЕСКОГО метода?

объект типа Class, соответствующий классу, в котором определен этот метод.

> Что такое volatile переменная?

При помощи ключевого слова volatile можно гарантировать, что переменная будет храниться в общей памяти, и потоки не будут ее брать себе в свой кеш. Это значит, что изменения, внесённые одним потоком, немедленно становятся видимыми для остальных потоков. Однако это не обеспечивает ее атомарность, т.к. все потоки имеют к ней доступ на запись, и может происходить гонка потоков.

> Каковы состояния в жизненном цикле потока?

1. New
2. Runnable
3. Running
4. Waiting/Blocked
5. Dead/Terminated

> Что такое демон-поток и можно ли сделать поток демоном уже после его создания?

Это фоновый поток, выполняемый системой параллельно с обычными прикладными потоками. Отличительной особенностью демона является то, что его жизнь напрямую связана с жизнью главного процесса: если завершатся все обычные (non-daemon) потоки, программа прекращает своё выполнение, даже если демон ещё активен. 
Нет, мы можем создать поток демона только до его запуска.

> Можно ли запустить тред дважды?

Нет, мы не можем перезапустить поток, так как после запуска и выполнения потока он переходит в состояние Dead. 

> Какая разница между процессом и потоком?

1. Программа в исполнении называется процессом, тогда как Поток является подмножеством процесса.
2. Процессы независимы, тогда как потоки являются подмножеством процесса.
3. Процессы имеют различное адресное пространство в памяти, в то время как потоки содержат общее адресное пространство.
4. Переключение контекста происходит быстрее между потоками по сравнению с процессами.
5. Межпроцессное взаимодействие медленнее и дороже, чем межпотоковое взаимодействие.
6. Любые изменения в родительском процессе не влияют на дочерний процесс, тогда как изменения в родительском потоке могут влиять на дочерний поток.

> Какой метод переведет состояние потока из Running в Runnable?

yield(); - Метод yield() используется для перевода потока из состояния Running (выполняется) в состояние Runnable (готов к выполнению).

> Какой метод переводит поток в режим ожидания?

wait() на объекте мониторе или sleep() на самом потоке

> Чем отличается синхронизация с помощью synchronized от использования ReentrantLock?

* synchronized — это встроенный механизм Java, используемый для защиты критических участков кода. При входе в синхронизированную область текущий поток приобретает блокировку, которая освобождается при завершении работы.
* ReentrantLock — это явный объект блокировки, позволяющий явно устанавливать блокировки и управлять ими (например, пытаться приобрести блокировку с таймаутом или попытаться завершить блокировку досрочно).

> Что такое "race condition" (состояние гонки)?

Race condition (состояние гонки) — это ситуация, когда несколько потоков пытаются одновременно изменить один и тот же ресурс, приводя к непредвиденному или некорректному результату. Чаще всего возникает, когда один поток меняет значение, а другой в это же время его читает или пишет.  

> В чём разница между wait() и sleep()?

* wait() — переводит поток в состояние ожидания до уведомления (notify() или notifyAll()) другим потоком. Он освобождает блокировку и ждет до появления события.
* sleep() — останавливает поток на определенный период времени, не освобождая блокировку.

> Что такое "deadlock" (мертвая блокировка)? Приведи пример.

Deadlock (мертвая блокировка) — это ситуация, когда два или более потоков ожидают друг друга, образуя замкнутый круг, и никто из них не может продолжать работу.

> Что такое Thread Pool (пул потоков)? Какие преимущества он дает? Какой класс используется для создания пула потоков, и какой отвечает за работу с ним?

Thread pool (пул потоков) — это совокупность готовых к выполнению потоков, управляемых специальным диспетчером. Он используется для повторного использования потоков и устранения расходов на постоянное создание/уничтожение потоков.

Преимущества:
* Экономия ресурсов: Повторное использование потоков устраняет затраты на их создание и уничтожение.
* Контроль производительности: Управляемое количество потоков позволяет избежать избыточной нагрузки на систему.
* Упрощение управления: Легче управлять пулом потоков, чем отдельными потоками.

Классы: статический класс Executors и класс ExecutorService

> Что такое CountDownLatch и как его использовать?  

CountDownLatch — это синхронизатор, который позволяет одному или нескольким потокам дождаться завершения определённого количества событий, происходящих в других потоках. Идеален для координации завершения параллельных задач. 

> В чем разница между Semaphore и ReentrantLock?

* Semaphore контролирует доступ к совместно используемому ресурсу посредством выдачи разрешительных токенов. Поток, желающий получить доступ, должен сначала захватить токен. Токены выдаются ограниченными количествами, регулируя число потоков, одновременно обращающихся к ресурсу.
* ReentrantLock позволяет потокам явно захватывать и освобождать блокировки, предоставляя больше контроля над ситуацией блокировок, чем стандартный synchronized. Поток может многократно входить в блокировку, а также использовать механизмы fair/unfair locking.

> В чем разница между CyclicBarrier и CountDownLatch?
Разница между CyclicBarrier и CountDownLatch в том, что CyclicBarrier ждет поступления определенного количества потоков в точке кода, а CountDownLatch ждет выполнения определенных событий (вызова countDown()) в коде.