> [НАЗАД к СОДЕРЖАНИЮ](README.md)

---

`Сериализация` — это процесс сохранения состояния объекта в последовательность байт.  
Десериализация — это процесс восстановления объекта из этих байт.  
Serializable (**сериалайзбл**) **Serializable - интерфейс-маркер.** Он просто помечает машине, что эти данные разрешено переводить в бинарные код.  
  * private transient String password;

  ### `Обычная серриализация/дессериализация: ` - процесс преобразования объектов в поток `байтов`

* Объект из файла:
```java
    public static Object deserialize(String filename) throws IOException, ClassNotFoundException {
        try (FileInputStream fileInputStream = new FileInputStream(filename);
             ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream)) {
            return objectInputStream.readObject();
        }
    }
```

* Объект в файл:
```java
    public static void serialize(Object object, String filename) throws IOException {
        try (FileOutputStream fileOutputStream = new FileOutputStream(filename);
             ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream)) {
            objectOutputStream.writeObject(object);
        }
    }
```

> Для кастомных типов - имплементировать `Serializeble` для серриализации!

### JAXB 

Статься: https://habr.com/ru/companies/simbirsoft/articles/704818/

JAXB (Java Architecture for XML Binding) — это специальный инструмент для маршалинга и демаршалинга объектов в XML.

JAXB предоставляет аннотации, которыми размечаются поля JAVA-классов.

Для начала необходимо создать требуемые классы.

Принцип получается примерно следующий: если тег имеет дочерние элементы или атрибуты, значит это объект. Если тег в документе не имеет дочерних элементов, значит это поле объекта.

`Аннтотации`:
- @XmlRootElement(name = "Screen") — определяет корневой элемент. Может быть указана над классом или полем класса;

- @XmlAccessorType(XmlAccessType.FIELD) — определяет сущности, которые используются в процессах преобразования; //для прямой связи полей с XML-элементами

- @XmlAttribute(name = "Stage") — определяет, что поле является атрибутом, а не тегом в XML-документе;

- @XmlElement(name = "Title") — определяет, что поле является тегом в XML-документе;

- @XmlElementWrapper(name="Buttons") — создает некоторую обертку вокруг группы повторяющихся тегов;

- @XMLValue — определяет, что поле содержит в себе значение тега.

Пример класса для `маршалинга` в XML:
```java
@Data
@XmlAccessorType(XmlAccessType.FIELD)
public class Book {
    @XmlElement(name = "TITLE")
    private final String title;
    @XmlElement(name = "AUTHOR")
    private final String author;
    @XmlElement(name = "PAGES")
    private final int pages;
    @XmlElement(name = "YEAR")
    private final String publicationDate;
    @XmlElement(name = "PRICE")
    private final double price;
}
```


### Форматы передачи данных JSON and XML

Две разновидности API:
* SOAP 1.2 с 2003г. (XML) (Simple Object Access Protocol) - актульный. Больше корпоративная история (ebay, salesFores, sage)
SOAP - это стандартизированный протокол, который отправляет сообщения с использованием других протоколов, таких как HTTP и др. 
* REST (JSON, редко - XML) с 2018г. (Facebook, Twitter, stripe) 
REST (Representational State Transfer) — это не протокол, а архитектурный стиль.
Архитектура REST устанавливает набор рекомендаций, которым необходимо следовать, если вы хотите
предоставить веб-службе RESTful, например, существование без сохранения состояния и использование кодов состояния HTTP.

`XML` (eXtensible Markup Language) — расширяемый язык разметки. Используется для хранения и передачи данных. Так что увидеть его можно не только в API, но и в коде.

`Пример Web-сервера на xml от OTUS:` [ссылка](https://github.com/timofeev-vadim-96/tlg-bot-exchange-rates/blob/main/src/main/java/org/example/util/XmlConverterUtil.java)

Проверка кода xml: https://jsonformatter.org/xml-formatter#Sample

![устройство xml](images/xml_image.png)

<req> - запрос

Стандарт построения запроса в XML - **XSD-схема**   

`XSD` (XML Schema Definition) — это описание вашего XML.
Как он должен выглядеть, что в нем должно быть? ТЗ, написанное на языке машины.

Если мы создаем SOAP-метод,
то указываем в схеме:
1. какие поля будут в запросе;
2. какие поля будут в ответе;
3. какие типы данных у каждого поля;
4. какие поля обязательны для заполнения, а какие нет;
5. есть ли у поля значение по умолчанию, и какое оно;
6. есть ли у поля ограничение по длине;
7. есть ли у поля другие параметры;
8. какая у запроса структура по вложенности элементов;
9. ...

![стандарт XSD для построения запросов XML](images/xsd-sheme.png)

Пример запроса по такой схеме:

![пример запроса на XML](images/request_example.png)

Правила оформления XML:
1. Есть корневой элемент.
2. У каждого элемента есть закрывающийся тег.
3. Теги регистрозависимы!
4. Соблюдается правильная вложенность элементов.
5. Атрибуты оформлены в кавычках.

Пример XML:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<root>
    <element attribute="value">Content</element>
    <nestedElement>
        <childElement>Child Content</childElement>
    </nestedElement>
</root>
```
```
Декларация: <?xml version="1.0" encoding="UTF-8"?> — указывает версию XML и кодировку.
Корневой элемент: В XML всегда должен быть один корневой элемент (в данном примере это <root>).
Теги (elements): Теги указываются в виде пар: открывающий (<element>) и закрывающий (</element>) теги. В них могут быть вложены другие теги или содержимое.
Атрибуты: Атрибуты содержатся в открывающем теге и задают метаданные элемента, например <element attribute="value">.
Иерархия: Элементы могут содержать вложенные элементы, что создает древовидную структуру данных.
```

`JSON` (англ. JavaScript Object Notation) — текстовый формат обмена данными, основанный на JavaScript. Но при этом формат независим от JS и может использоваться в любом языке программирования.

**JSON-объект** — это неупорядоченное множество пар «ключ:значение».

Правила оформления JSON
1. Данные написаны в виде пар «ключ:значение». ключ всегда String
2. Данные разделены запятыми
3. Объект находится внутри фигурных скобок {}
4. Массив — внутри квадратных []

---


```java
        JsonObject jsonObject = JsonConverterUtil.getJsonObjectFromString(response.body()); //с помощью своего утильного класса
        System.out.println(jsonObject.get("result").getAsJsonObject().get("username"));
```

---

### библиотека `Jackson` - Для работы с Json и XML

> Чтобы игнорировать поле при серриализации:     @JsonIgnore private transient double GPA;

```java
//СЕРИАЛИЗАЦИЯ объекта в файл
    public static void saveTasksToFile(String fileName, List<ToDoV2> tasks) {
        try {
            if (fileName.endsWith(".json")) {
                objectMapper.configure(SerializationFeature.INDENT_OUTPUT, true); //INDENT_OUTPUT - красивая запись с пробелами
                objectMapper.writeValue(new File(fileName), tasks);
            } else if (fileName.endsWith(".bin")) { //обычная бинарная запись
                try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(fileName))) {
                    oos.writeObject(tasks);
                }
            } else if (fileName.endsWith(".xml")) { //запись в XML
                xmlMapper.configure(SerializationFeature.INDENT_OUTPUT, true);
                xmlMapper.writeValue(new File(fileName), tasks);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

//ДЕССЕРИАЛИЗАЦИЯ объекта из файла (даже составного - список с объектами)
    public static List<ToDoV2> loadTasksFromFile(String fileName) {
        List<ToDoV2> tasks = new ArrayList<>();

        File file = new File(fileName);
        if (file.exists()) {
            //дессериализуем составной тип объекта
            try {
                //JSON
                if (fileName.endsWith(".json")) {
                    tasks = objectMapper.readValue(file, objectMapper.getTypeFactory().constructCollectionType(List.class, ToDoV2.class));
                    //БИНАРНЫЙ файл
                } else if (fileName.endsWith(".bin")) {
                    try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file))) {
                        tasks = (List<ToDoV2>) ois.readObject();
                    }
                    //XML
                } else if (fileName.endsWith(".xml")) {
                    tasks = xmlMapper.readValue(file, xmlMapper.getTypeFactory().constructCollectionType(List.class, ToDoV2.class));
                }
            } catch (IOException | ClassNotFoundException e) {
                e.printStackTrace();
            }
        }

        return tasks;
    }
```

`Аннотации Jackson`:  
```java
//игонорировать свойства, не заданные в данном классе
@JsonIgnoreProperties(ignoreUnknown = true) 
public class Country {
    //свойства
}
```


интерфейс `Externalizable` - для самостоятельной реализации серриализации и дессериализации

> при дессериализации стоит сохранять порядок полей. Если в файле первое поле "name", то и читать его стоит первым.

//реализуемые методы в классе объекта
```java
    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeObject(title);
        out.writeBoolean(isDone);
    }

//поля в строгом записанном порядке
    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        title = (String) in.readObject();
        isDone = in.readBoolean();
    }
``` 

Пример как вытащить любое поле из json:
```java
        JsonObject jsonObject = JsonConverterUtil.getJsonObjectFromString(response.body()); //с помощью своего утильного класса
        System.out.println(jsonObject.get("result").getAsJsonObject().get("username"));
```

`ObjectMapper` - Json конвертер из библиотеки Jackson
топ методы:
  * objectMapper.writeValueAsString(myObject)
  * objectMapper.readValue(json, MyObject.class);

Настройка ObjectMapper
```java
ObjectMapper objectMapper = new ObjectMapper();

// Пример: включение красивого вывода JSON
objectMapper.writerWithDefaultPrettyPrinter();

// Пример: игнорирование нулевых значений при сериализации
objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);

// Пример: отключение генерации исключения при неизвестных полях при десериализации
objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

// Отключает запись дат в виде временных меток.
objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false): 

// Пример: использование стратегии именования полей в стиле "snake_case"
objectMapper.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);

//Позволяет зарегистрировать собственные сериализаторы и десериализаторы.
registerModule(new SimpleModule().addSerializer(...).addDeserializer(...)): 
```

`Проблемы ObjectMapper` и их решение:

**Отсутствие конструктора без аргументов:**
**Проблема:** Если класс, в который вы пытаетесь десериализовать JSON, не имеет конструктора без аргументов, Jackson не сможет создать экземпляр класса.

**Решение:** Добавьте конструктор без аргументов в свой класс или используйте аннотацию `@JsonCreator` для указания конструктора, который следует использовать при десериализации.

**Отсутствие сеттеров:**
**Проблема:** Если у класса отсутствуют сеттеры для полей, Jackson может столкнуться с проблемой установки значений полей.

**Решение:** Добавьте сеттеры для соответствующих полей в вашем классе.

**Несовпадение имен полей:**
**Проблема:** Если имена полей в JSON не соответствуют именам полей в классе, Jackson может не смочь правильно провести десериализацию.

**Решение:** Используйте аннотации, такие как `@JsonProperty` для сопоставления имен полей в JSON с именами полей в Java-классе.

**Отсутствие геттеров:**
**Проблема:** Если у класса отсутствуют геттеры для полей, Jackson может столкнуться с проблемой получения значений полей.

**Решение:** Добавьте геттеры для соответствующих полей в вашем классе.

**Несовпадение типов данных:**
**Проблема:** Если тип данных поля в классе отличается от типа данных в JSON, Jackson может не смочь провести десериализацию.

**Решение:** Убедитесь, что типы данных соответствуют друг другу, или используйте соответствующие аннотации, такие как `@JsonTypeInfo`, чтобы указать информацию о типе.

**Некорректный формат JSON:**
**Проблема:** Если JSON имеет некорректный формат, Jackson может выдавать ошибки.

**Решение:** Проверьте, что ваш JSON соответствует правильному формату. Можно использовать онлайн-инструменты для проверки корректности JSON.

**Наличие лишних полей в JSON:**
**Проблема:** Если JSON содержит дополнительные поля, которые отсутствуют в Java-классе, Jackson может вызывать ошибки.

**Решение:** Используйте аннотацию `@JsonIgnoreProperties(ignoreUnknown = true)` над классом для игнорирования лишних полей.

@JsonView - аннотация, которая позволяет ограничить предоставление СУЩНОСТИ(хз зачем отдавать ее наверх) по методам контроллера.

Пример:
```java
public class Views {
    public static class Public {}
    public static class Internal extends Public {}
}

public class MyData {
    @JsonView(Views.Public.class)
    private String publicField;

    @JsonView(Views.Internal.class)
    private String internalField;
}

@RestController
public class MyController {

    @GetMapping("/publicData")
    @JsonView(Views.Public.class)
    public MyData getPublicData() {
        // Возвращаем данные, которые будут включены в JSON только для Views.Public
    }

    @GetMapping("/internalData")
    @JsonView(Views.Internal.class)
    public MyData getInternalData() {
        // Возвращаем данные, которые будут включены в JSON только для Views.Internal
    }
}
```